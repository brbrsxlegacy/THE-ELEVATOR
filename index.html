<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Asansör</title>
  <style>
    :root{
      --bg:#2d2a1f;
      --paper:#746c4c;
      --dirty:#5e573d;
      --line:#3a3526;
      --text:#e0d8b8;
      --mute:#b8ae87;
      --dark:#0a0a09;
    }
    *{box-sizing:border-box}
    html,body{margin:0;height:100%;overflow:hidden;background:var(--bg);font-family:Verdana,Arial,sans-serif;color:var(--text)}
    canvas{display:block;width:100vw;height:100vh;background:#575236}

    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10}
    #menu{background:radial-gradient(circle at 50% 30%, rgba(153,146,106,.24), rgba(35,32,22,.9) 62%)}
    .hidden{display:none}
    #playBtn{
      border:1px solid #857b57;
      background:#6b6345;
      color:#ede4bf;
      letter-spacing:3px;
      font-size:26px;
      padding:18px 48px;
      cursor:pointer;
    }
    #playBtn:hover{background:#766d4d}

    #tinyHUD{
      position:fixed;left:12px;top:10px;z-index:4;
      font-size:12px;line-height:1.45;color:var(--mute);
      background:rgba(44,41,30,.45);border:1px solid rgba(131,120,85,.45);padding:6px 8px;
    }
    #prompt{
      position:fixed;left:50%;bottom:32px;transform:translateX(-50%);
      z-index:6;font-size:14px;letter-spacing:1px;
      border:1px solid #837953;background:rgba(52,48,34,.85);padding:8px 11px;display:none;
    }
    #prompt.show{display:block}

    #chestPanel{
      position:fixed;inset:0;z-index:12;display:none;align-items:center;justify-content:center;
      background:rgba(7,7,6,.74);
    }
    #chestPanel.show{display:flex}
    .panel{
      width:min(360px,88vw);padding:14px;background:#524b34;border:1px solid #8f8360;
    }
    .panel h3{margin:0 0 10px;font-size:13px;font-weight:700;letter-spacing:1px;color:#d8cfa7}
    .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:7px}
    .slot{aspect-ratio:1/1;border:1px solid #8f8360;background:#665d40;display:flex;align-items:center;justify-content:center;font-size:10px;cursor:pointer;color:#f3e8b8}
    .slot.empty{background:#4f4832;border-color:#796f4e;cursor:default;color:#7c7357}
    .panel p{font-size:11px;color:#c4b98f;margin:8px 0 0}

    #death,#ending{
      position:fixed;inset:0;z-index:14;display:none;align-items:center;justify-content:center;
      text-align:center;background:rgba(0,0,0,.92);color:#d8d0ae;letter-spacing:2px
    }
    #death.show,#ending.show{display:flex}
    #ending p,#death p{font-size:24px;margin:0}
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="menu" class="overlay"><button id="playBtn">OYNA</button></div>
  <div id="tinyHUD">KAT: 1 / 100<br>ENVANTER: -</div>
  <div id="prompt"></div>

  <div id="chestPanel">
    <div class="panel">
      <h3>DOLAP / ÇEKMECE</h3>
      <div id="slots" class="grid"></div>
      <p>Eşyayı almak için slota tıkla. Kapat: ESC</p>
    </div>
  </div>

  <div id="death"><p>YAKALANDIN</p></div>
  <div id="ending"><p>Hiçbir zaman yukarı çıkmıyordun.</p></div>

  <script>
    const cv = document.getElementById('game');
    const cx = cv.getContext('2d');
    const menu = document.getElementById('menu');
    const playBtn = document.getElementById('playBtn');
    const tinyHUD = document.getElementById('tinyHUD');
    const prompt = document.getElementById('prompt');
    const chestPanel = document.getElementById('chestPanel');
    const slotsEl = document.getElementById('slots');
    const deathUI = document.getElementById('death');
    const endingUI = document.getElementById('ending');

    const CHUNK_W = 820;
    const FLOOR_H = 580;
    const STATE = {MENU:0,PLAY:1,CHEST:2,ELEVATOR:3,CAUGHT:4,ENDING:5};

    let state = STATE.MENU;
    let floor = 1;
    let floorSeed = 1;
    let elevatorTimer = 0;
    let caughtTimer = 0;
    let endingTimer = 0;
    let zoom = 1;

    const keys = new Set();
    const inventory = {key:false,card:false};
    let chestSlots = [];

    const player = {x:100,y:300,speed:128,r:9};
    const cam = {x:0,y:0};
    let chunks = new Map();
    let monsters = [];
    let interactable = {type:null,obj:null};

    let elevator = {x:620,y:290,w:40,h:52};
    let cabinet = {x:360,y:300,w:32,h:26,opened:false,looted:false,loot:'key'};

    function resize(){ cv.width = innerWidth; cv.height = innerHeight; }
    addEventListener('resize', resize); resize();

    addEventListener('keydown', e => {
      keys.add(e.key.toLowerCase());
      if (e.key.toLowerCase() === 'e') interact();
      if (e.key === 'Escape' && state === STATE.CHEST) closeChest();
    });
    addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

    function rng(seed){
      let t = seed >>> 0;
      return () => {
        t += 0x6D2B79F5;
        let r = Math.imul(t ^ t >>> 15, 1 | t);
        r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
        return ((r ^ r >>> 14) >>> 0) / 4294967296;
      };
    }

    function needItem(){ return floor % 2 === 0 ? 'card' : 'key'; }

    function resetFloor(){
      floorSeed = floor * 9973;
      chunks = new Map();
      generateChunk(-1); generateChunk(0); generateChunk(1);
      const central = chunks.get('0,0');
      player.x = 100;
      player.y = 280;
      cam.x = player.x;
      cam.y = player.y;

      const rr = rng(floorSeed + 66);
      elevator = {x:CHUNK_W * 0 + 620 + Math.floor(rr()*90), y:260 + Math.floor(rr()*70), w:42, h:56};
      cabinet = {
        x:CHUNK_W * 0 + 260 + Math.floor(rr()*260),
        y:250 + Math.floor(rr()*120),
        w:34,h:24, opened:false, looted:false,
        loot: needItem()
      };

      monsters = [];
      const mCount = Math.min(8, 2 + Math.floor(floor/13));
      for(let i=0;i<mCount;i++){
        const mr = rng(floorSeed + i*21 + 777);
        const cxIdx = Math.floor(mr()*3)-1;
        monsters.push({
          x: cxIdx*CHUNK_W + 120 + mr()*560,
          y: 120 + mr()*340,
          spd: 35 + mr()*18
        });
      }
    }

    function generateChunk(ix){
      const key = `${ix},0`;
      if(chunks.has(key)) return;
      const r = rng(floorSeed + ix*131);
      const halls = [];
      const walls = [];
      const blocks = 4 + Math.floor(r()*4);
      let x = ix*CHUNK_W + 40;
      for(let i=0;i<blocks;i++){
        const w = 110 + r()*220;
        const h = 90 + r()*180;
        const y = 40 + r()*(FLOOR_H-h-40);
        halls.push({x,y,w,h,tone:Math.floor(r()*20)-10});

        const edge = 8;
        walls.push({x:x-edge,y:y-edge,w:w+edge*2,h:edge,noise:r()*999});
        walls.push({x:x-edge,y:y+h,w:w+edge*2,h:edge,noise:r()*999});
        walls.push({x:x-edge,y:y,w:edge,h:h,noise:r()*999});
        walls.push({x:x+w,y:y,w:edge,h:h,noise:r()*999});

        const obstacles = 1 + Math.floor(r()*2);
        for(let j=0;j<obstacles;j++){
          const ow = 18 + r()*34;
          const oh = 18 + r()*34;
          const ox = x + 14 + r()*Math.max(4,w-ow-28);
          const oy = y + 14 + r()*Math.max(4,h-oh-28);
          walls.push({x:ox,y:oy,w:ow,h:oh,noise:r()*999});
        }

        x += w + 35 + r()*70;
      }
      chunks.set(key,{ix,halls,walls,noise:r()*999});
    }

    function circleRectHit(px,py,pr,rect){
      const nx = Math.max(rect.x, Math.min(px, rect.x + rect.w));
      const ny = Math.max(rect.y, Math.min(py, rect.y + rect.h));
      const dx = px - nx;
      const dy = py - ny;
      return (dx*dx + dy*dy) < pr*pr;
    }

    function collidesWithWall(x,y){
      const ix = Math.floor(x / CHUNK_W);
      for(let d=-2; d<=2; d++){
        const entry = chunks.get(`${ix+d},0`);
        if(!entry) continue;
        for(const wall of entry.walls){
          if(circleRectHit(x,y,player.r,wall)) return true;
        }
      }
      return false;
    }

    function ensureChunks(){
      const ix = Math.floor(player.x / CHUNK_W);
      for(let d=-2; d<=2; d++) generateChunk(ix+d);
    }

    function update(dt){
      if(state === STATE.PLAY){
        let vx = 0, vy = 0;
        if(keys.has('a') || keys.has('arrowleft')) vx -= 1;
        if(keys.has('d') || keys.has('arrowright')) vx += 1;
        if(keys.has('w') || keys.has('arrowup')) vy -= 1;
        if(keys.has('s') || keys.has('arrowdown')) vy += 1;
        const len = Math.hypot(vx,vy) || 1;
        const stepX = (vx/len) * player.speed * dt;
        const stepY = (vy/len) * player.speed * dt;

        const nx = player.x + stepX;
        if(!collidesWithWall(nx, player.y)) player.x = nx;

        const ny = player.y + stepY;
        if(!collidesWithWall(player.x, ny)) player.y = ny;

        player.y = Math.max(40, Math.min(FLOOR_H-40, player.y));

        ensureChunks();
        updateMonsters(dt);
        updateInteraction();

        cam.x += (player.x - cam.x)*0.08;
        cam.y += (player.y - cam.y)*0.08;
      }

      if(state === STATE.ELEVATOR){
        elevatorTimer += dt;
        cam.x += (elevator.x - cam.x)*0.03;
        cam.y += (elevator.y - cam.y)*0.03;
        if(floor < 100 && elevatorTimer > 2.2){
          floor++;
          inventory.key = false;
          inventory.card = false;
          state = STATE.PLAY;
          elevatorTimer = 0;
          resetFloor();
        }
        if(floor === 100){
          endingTimer += dt;
          cam.y += Math.sin(endingTimer*28) * 2.4;
          if(endingTimer > 4){
            state = STATE.ENDING;
            endingUI.classList.add('show');
          }
        }
      }

      if(state === STATE.CAUGHT){
        caughtTimer += dt;
        zoom += dt * 0.28;
        if(caughtTimer > 2.8) deathUI.classList.add('show');
      }

      updateHUD();
    }

    function updateMonsters(dt){
      for(const m of monsters){
        const dx = player.x - m.x;
        const dy = player.y - m.y;
        const d = Math.hypot(dx,dy) || 1;
        m.x += (dx/d) * m.spd * dt;
        m.y += (dy/d) * m.spd * dt;
        if(d < 16 && state === STATE.PLAY){
          state = STATE.CAUGHT;
          caughtTimer = 0;
        }
      }
    }

    function updateInteraction(){
      interactable = {type:null,obj:null};
      const dCab = Math.hypot(player.x-cabinet.x, player.y-cabinet.y);
      const dElv = Math.hypot(player.x-elevator.x, player.y-elevator.y);
      if(!cabinet.looted && dCab < 55){
        interactable = {type:'cabinet',obj:cabinet};
        showPrompt('[E] AÇ');
        return;
      }
      if(dElv < 64){
        interactable = {type:'elevator',obj:elevator};
        const req = needItem() === 'key' ? 'Anahtar' : 'Kart';
        showPrompt(`[E] ASANSÖR (${req} GEREKLİ)`);
        return;
      }
      hidePrompt();
    }

    function interact(){
      if(state !== STATE.PLAY) return;
      if(interactable.type === 'cabinet') openChest();
      if(interactable.type === 'elevator'){
        const req = needItem();
        if(inventory[req]){
          state = STATE.ELEVATOR;
          elevatorTimer = 0;
          endingTimer = 0;
        }
      }
    }

    function openChest(){
      state = STATE.CHEST;
      chestPanel.classList.add('show');
      chestSlots = Array.from({length:8}, ()=> null);
      const r = rng(floorSeed + 444);
      chestSlots[Math.floor(r()*8)] = cabinet.loot;
      renderSlots();
    }

    function closeChest(){
      chestPanel.classList.remove('show');
      state = STATE.PLAY;
      if(inventory[cabinet.loot]) cabinet.looted = true;
    }

    function renderSlots(){
      slotsEl.innerHTML = '';
      chestSlots.forEach((it, idx) => {
        const d = document.createElement('div');
        d.className = 'slot' + (it ? '' : ' empty');
        d.textContent = it ? (it === 'key' ? 'ANAHTAR' : 'KART') : '';
        if(it){
          d.onclick = () => {
            inventory[it] = true;
            chestSlots[idx] = null;
            renderSlots();
          };
        }
        slotsEl.appendChild(d);
      });
    }

    function draw(){
      cx.setTransform(1,0,0,1,0,0);
      cx.clearRect(0,0,cv.width,cv.height);
      cx.fillStyle = '#625a3e';
      cx.fillRect(0,0,cv.width,cv.height);

      cx.save();
      cx.translate(cv.width/2, cv.height/2);
      cx.scale(zoom, zoom);
      cx.translate(-cam.x, -cam.y);

      const currentIx = Math.floor(player.x / CHUNK_W);
      for(const entry of chunks.values()){
        const dist = Math.abs(entry.ix - currentIx);

        for(const h of entry.halls){
          const base = 124 + h.tone;
          cx.fillStyle = `rgb(${base+16},${base+12},${base-10})`;
          cx.fillRect(h.x,h.y,h.w,h.h);
          cx.strokeStyle = 'rgba(48,44,31,.55)';
          cx.strokeRect(h.x,h.y,h.w,h.h);
        }

        for(const wall of entry.walls){
          const grad = cx.createLinearGradient(wall.x, wall.y, wall.x + wall.w, wall.y + wall.h);
          grad.addColorStop(0, '#141311');
          grad.addColorStop(1, '#080807');
          cx.fillStyle = grad;
          cx.fillRect(wall.x,wall.y,wall.w,wall.h);

          const speckCount = Math.max(1, Math.floor((wall.w * wall.h) / 180));
          for(let i=0;i<speckCount;i++){
            const n = Math.sin((wall.noise + i*31.7) * 0.73);
            const fx = ((n * 43758.5453) % 1 + 1) % 1;
            const fy = ((Math.sin((wall.noise + i*19.3) * 1.17) * 9631.12) % 1 + 1) % 1;
            const a = 0.04 + (((Math.sin((wall.noise + i*7.1)*3.7)+1)*0.5) * 0.09);
            cx.fillStyle = `rgba(182,170,126,${a})`;
            cx.fillRect(wall.x + fx*wall.w, wall.y + fy*wall.h, 2, 2);
          }
          cx.strokeStyle = 'rgba(24,24,21,.8)';
          cx.strokeRect(wall.x,wall.y,wall.w,wall.h);
        }
        if(dist > 0){
          cx.fillStyle = `rgba(35,33,25,${Math.min(0.7, dist*0.22)})`;
          cx.fillRect(entry.ix*CHUNK_W, 0, CHUNK_W, FLOOR_H);
        }
      }

      drawCabinet();
      drawElevator();
      monsters.forEach(drawMonster);
      drawPlayer();

      cx.restore();

      const vignette = cx.createRadialGradient(cv.width/2, cv.height/2, 120, cv.width/2, cv.height/2, Math.max(cv.width,cv.height)*0.65);
      vignette.addColorStop(0, 'rgba(0,0,0,0)');
      vignette.addColorStop(1, 'rgba(0,0,0,0.74)');
      cx.fillStyle = vignette;
      cx.fillRect(0,0,cv.width,cv.height);

      if(state === STATE.CAUGHT){
        const a = Math.min(1, caughtTimer/3);
        cx.fillStyle = `rgba(0,0,0,${a})`;
        cx.fillRect(0,0,cv.width,cv.height);
      }

      if(state === STATE.ELEVATOR && floor === 100){
        const a = Math.min(1, endingTimer/4);
        cx.fillStyle = `rgba(0,0,0,${a*0.9})`;
        cx.fillRect(0,0,cv.width,cv.height);
      }
    }

    function drawPlayer(){
      const jitter = Math.sin(performance.now()*0.006)*0.9;
      cx.fillStyle = '#171715';
      cx.beginPath();
      cx.ellipse(player.x, player.y+jitter, player.r+1, 14, 0, 0, Math.PI*2);
      cx.fill();
    }

    function drawMonster(m){
      cx.fillStyle = '#000';
      cx.beginPath();
      cx.ellipse(m.x, m.y, 12, 16, 0, 0, Math.PI*2);
      cx.fill();
      cx.fillStyle = '#fff';
      cx.fillRect(m.x-5,m.y-2,3,3);
      cx.fillRect(m.x+2,m.y-2,3,3);
    }

    function drawElevator(){
      cx.fillStyle = '#4b4637';
      cx.fillRect(elevator.x-20,elevator.y-26,elevator.w,elevator.h);
      cx.fillStyle = '#7f765d';
      cx.fillRect(elevator.x-16,elevator.y-22,14,48);
      cx.fillRect(elevator.x+2,elevator.y-22,14,48);
    }

    function drawCabinet(){
      if(cabinet.looted) return;
      cx.fillStyle = '#3e3726';
      cx.fillRect(cabinet.x-16,cabinet.y-12,cabinet.w,cabinet.h);
      cx.fillStyle = '#6f664b';
      cx.fillRect(cabinet.x-16,cabinet.y-12,cabinet.w,5);
    }

    function showPrompt(t){ prompt.textContent = t; prompt.classList.add('show'); }
    function hidePrompt(){ prompt.classList.remove('show'); }

    function updateHUD(){
      const items = [];
      if(inventory.key) items.push('Anahtar');
      if(inventory.card) items.push('Kart');
      tinyHUD.innerHTML = `KAT: ${floor} / 100<br>ENVANTER: ${items.length?items.join(' • '):'-'}`;
    }

    let last = performance.now();
    function loop(t){
      const dt = Math.min(0.033, (t-last)/1000);
      last = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    playBtn.onclick = () => {
      menu.classList.add('hidden');
      deathUI.classList.remove('show');
      endingUI.classList.remove('show');
      state = STATE.PLAY;
      floor = 1;
      inventory.key = false;
      inventory.card = false;
      zoom = 1;
      resetFloor();
    };

    requestAnimationFrame(loop);
  </script>
</body>
</html>
