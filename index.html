<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Elevator</title>
  <style>
    :root{
      --bg:#05060a;
      --fg:#eaf2ff;
      --muted:#a8b6c6;
      --glass: rgba(18, 24, 44, .72);
      --glass2: rgba(10, 14, 26, .78);
      --line: rgba(255,255,255,.10);
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    canvas{width:100vw; height:100vh; display:block; image-rendering:pixelated; image-rendering:crisp-edges; background:#02030a;}

    .hud{
      position:fixed; left:14px; top:14px;
      display:flex; gap:10px; flex-wrap:wrap;
      z-index:20; user-select:none; pointer-events:none;
    }
    .chip{
      background:var(--glass);
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 12px;
      font-size:13px;
      letter-spacing:.2px;
      backdrop-filter: blur(10px);
    }
    .chip b{font-weight:800; color:var(--fg)}

    .toast{
      position:fixed; right:14px; top:14px;
      max-width:min(560px, calc(100vw - 28px));
      background:var(--glass2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      line-height:1.35;
      z-index:30;
      opacity:0;
      transform: translateY(-8px);
      transition:.18s ease;
      user-select:none;
      pointer-events:none;
      white-space:pre-line;
      backdrop-filter: blur(10px);
    }
    .toast.show{opacity:1; transform:translateY(0);}

    .menu{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      z-index:50;
      background:
        radial-gradient(1000px 700px at 20% 20%, rgba(106,215,255,.18), transparent 60%),
        radial-gradient(900px 600px at 80% 70%, rgba(255,79,123,.14), transparent 55%),
        radial-gradient(800px 600px at 40% 90%, rgba(255,227,123,.10), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.65));
    }
    .card{
      width:min(780px, calc(100vw - 28px));
      background:rgba(10, 14, 26, .84);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:18px;
      box-shadow: 0 22px 80px rgba(0,0,0,.62);
      backdrop-filter: blur(12px);
    }
    .row{display:flex; gap:14px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .title{font-size:26px; font-weight:900; letter-spacing:.6px;}
    .sub{color:var(--muted); margin-top:6px; font-size:14px; line-height:1.45;}
    .grid{display:grid; grid-template-columns: 1.1fr .9fr; gap:14px; margin-top:14px;}
    @media (max-width:860px){ .grid{grid-template-columns:1fr;} }
    .panel{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:16px;
      padding:14px;
    }
    .panel h3{margin:0 0 8px; font-size:14px; letter-spacing:.2px;}
    .panel p{margin:0; color:var(--muted); font-size:13px; line-height:1.45;}
    .kbd{
      display:inline-block;
      padding:2px 7px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      font-size:12px;
      margin:0 2px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      transition:.15s ease;
    }
    button:hover{transform: translateY(-1px); border-color: rgba(106,215,255,.38);}
    button:active{transform: translateY(0);}
    .danger{border-color: rgba(255,79,123,.34);}
    .danger:hover{border-color: rgba(255,79,123,.55);}
    .hide{display:none!important;}
    .small{margin-top:10px; color:var(--muted); font-size:12px; line-height:1.45;}
  </style>
</head>
<body>
<canvas id="cv"></canvas>

<div class="hud" id="hud">
  <div class="chip">Kat: <b id="uiFloor">1</b>/100</div>
  <div class="chip">Can: <b id="uiHP">3</b></div>
  <div class="chip">Anahtar: <b id="uiKey">0</b></div>
  <div class="chip">Görev: <b id="uiGoal">-</b></div>
  <div class="chip">Canavar: <b id="uiMonster">-</b></div>
</div>

<div class="toast" id="toast"></div>

<div class="menu" id="menu">
  <div class="card">
    <div class="row">
      <div>
        <div class="title">The Elevator</div>
        <div class="sub">
          2D pikselli asansör kaçış oyunu. 100. kata ulaş.<br>
          Her katta farklı hedef, canavarlar görünür.
        </div>
      </div>
      <div class="btns">
        <button id="btnStart">Başlat</button>
        <button id="btnHow">Kontroller</button>
        <button id="btnReset" class="danger">Sıfırla</button>
      </div>
    </div>

    <div class="grid hide" id="howPanel">
      <div class="panel">
        <h3>Kontroller</h3>
        <p>
          Hareket: <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">←</span><span class="kbd">→</span><br>
          Etkileşim: <span class="kbd">W</span> / <span class="kbd">↑</span><br>
          Saklan (dolap): <span class="kbd">Space</span><br>
          Asansör: <span class="kbd">Enter</span><br>
          Menü: <span class="kbd">Esc</span>
        </p>
      </div>
      <div class="panel">
        <h3>Kat Görevleri</h3>
        <p>
          Anahtar bul, sigorta onar, şifre çöz, kol çek.<br>
          Görev bitmeden asansör çalışmaz.
        </p>
        <div class="small">Not: Tarayıcı gerçek tam ekran için izin ister. İstersen F11 kullan.</div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* =========================
     Canvas setup
  ========================= */
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width = Math.floor(window.innerWidth * dpr);
    cv.height = Math.floor(window.innerHeight * dpr);
  }
  window.addEventListener("resize", fitCanvas);
  fitCanvas();

  /* =========================
     UI
  ========================= */
  const hud = document.getElementById("hud");
  const menu = document.getElementById("menu");
  const toast = document.getElementById("toast");

  const uiFloor = document.getElementById("uiFloor");
  const uiHP = document.getElementById("uiHP");
  const uiKey = document.getElementById("uiKey");
  const uiGoal = document.getElementById("uiGoal");
  const uiMonster = document.getElementById("uiMonster");

  let toastTimer = 0;
  function showToast(text, ms=2400){
    toast.textContent = text;
    toast.classList.add("show");
    toastTimer = ms;
  }

  /* =========================
     Helpers
  ========================= */
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const chance = (p)=>Math.random()<p;

  function now(){ return performance.now(); }

  function hashStr(s){
    let h=2166136261>>>0;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h>>>0;
  }
  function seededRand(seed){
    let x = seed>>>0;
    return () => {
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    };
  }

  /* =========================
     Monster Names (unique per floor)
  ========================= */
  const nameA = ["Noct","Vanta","Ruin","Gloom","Sable","Grim","Dread","Murk","Void","Shade","Crypt","Cinder","Hollow","Wraith","Ash","Frost"];
  const nameB = ["Runner","Seer","Stalker","Crawler","Drifter","Whisper","Warden","Ripper","Echo","Binder","Harrier","Mangler","Sunder","Lurker","Slink","Watcher"];
  const nameC = ["I","II","III","IV","V","VI","VII","VIII","IX","X"];

  function monsterNameForFloor(floor){
    const rnd = seededRand(hashStr("Monster:"+floor));
    const a = nameA[Math.floor(rnd()*nameA.length)];
    const b = nameB[Math.floor(rnd()*nameB.length)];
    const c = nameC[Math.floor(rnd()*nameC.length)];
    return a + " " + b + " " + c;
  }

  /* =========================
     Palettes (more colorful)
  ========================= */
  function paletteForFloor(floor){
    const rnd = seededRand(hashStr("Pal:"+floor));
    const hues = [195, 320, 42, 265, 155, 10, 230, 285, 90, 340];
    const baseHue = hues[Math.floor(rnd()*hues.length)];
    const accentHue = (baseHue + 70 + Math.floor(rnd()*70)) % 360;
    const sat1 = 72 + Math.floor(rnd()*18);
    const sat2 = 70 + Math.floor(rnd()*20);

    const bg1 = `hsl(${baseHue} ${sat1}% ${10 + Math.floor(rnd()*6)}%)`;
    const bg2 = `hsl(${(baseHue+22)%360} ${sat1}% ${6 + Math.floor(rnd()*5)}%)`;
    const wall = `hsl(${(baseHue+8)%360} ${sat1}% ${14 + Math.floor(rnd()*6)}%)`;
    const panel = `hsl(${(baseHue+14)%360} ${sat1}% ${18 + Math.floor(rnd()*6)}%)`;
    const neon = `hsl(${accentHue} ${sat2}% ${62 + Math.floor(rnd()*12)}%)`;
    const warn = `hsl(${(accentHue+170)%360} ${88}% ${60}%)`;
    const good = `hsl(${(accentHue+40)%360} ${80}% ${62}%)`;

    return { bg1, bg2, wall, panel, neon, warn, good };
  }

  /* =========================
     Procedural room (different sizes / placements)
  ========================= */
  function roomForFloor(floor){
    const rnd = seededRand(hashStr("Room:"+floor));
    const W = cv.width, H = cv.height;

    const floorY = Math.floor(H * (0.80 + (rnd()*0.03 - 0.015)));
    const minRatio = 0.58, maxRatio = 0.88;
    const ratio = minRatio + (maxRatio-minRatio) * (0.20 + 0.80*rnd());
    const roomW = Math.floor(W * ratio);

    const leftWall = Math.floor((W-roomW)/2);
    const rightWall = leftWall + roomW;

    const elevW = Math.floor(130 + rnd()*110);
    const elevH = Math.floor(H * (0.30 + rnd()*0.10));
    const elevX = Math.floor(rightWall - elevW - (40 + rnd()*60));
    const elevY = Math.floor(floorY - elevH - (40 + rnd()*40));

    const lockerW = Math.floor(62 + rnd()*46);
    const lockerH = Math.floor(H * (0.17 + rnd()*0.08));
    const lockerX = Math.floor(leftWall + (40 + rnd()*110));
    const lockerY = Math.floor(floorY - lockerH);

    const deskW = Math.floor(120 + rnd()*150);
    const deskH = Math.floor(44 + rnd()*60);
    const deskX = Math.floor(leftWall + roomW*(0.34 + rnd()*0.24));
    const deskY = Math.floor(floorY - deskH);

    // extra objects for goals
    const panelW = Math.floor(110 + rnd()*90);
    const panelH = Math.floor(60 + rnd()*40);
    const panelX = Math.floor(leftWall + roomW*(0.18 + rnd()*0.22));
    const panelY = Math.floor(floorY - panelH - (40 + rnd()*40));

    const keypadW = 56;
    const keypadH = 70;
    const keypadX = Math.floor(elevX - (70 + rnd()*80));
    const keypadY = Math.floor(elevY + (40 + rnd()*70));

    const leverW = 48;
    const leverH = 80;
    const leverX = Math.floor(leftWall + roomW*(0.65 + rnd()*0.18));
    const leverY = Math.floor(floorY - leverH - (40 + rnd()*30));

    // “clue note” positions
    const noteX = Math.floor(leftWall + 60 + rnd()*(roomW-140));
    const noteY = Math.floor(floorY - 220 - rnd()*140);

    return {
      W,H,floorY,leftWall,rightWall,
      elevX,elevY,elevW,elevH,
      doorW: Math.floor(elevW*0.42),
      doorH: Math.floor(elevH*0.62),
      lockerX,lockerY,lockerW,lockerH,
      deskX,deskY,deskW,deskH,
      panelX,panelY,panelW,panelH,
      keypadX,keypadY,keypadW,keypadH,
      leverX,leverY,leverW,leverH,
      noteX,noteY
    };
  }

  /* =========================
     Goals per floor (varies)
  ========================= */
  const GoalType = {
    NONE:"none",
    FIND_KEY:"find_key",
    FIX_FUSE:"fix_fuse",
    KEYPAD_CODE:"keypad_code",
    PULL_LEVER:"pull_lever"
  };

  function goalForFloor(floor){
    const rnd = seededRand(hashStr("Goal:"+floor));
    // pattern: mix variety, make later floors more complex
    const t = clamp((floor-1)/99, 0, 1);

    // deterministic selection
    const roll = rnd();
    if (floor === 1) return { type: GoalType.NONE, text:"Serbest", done:true };
    if (floor % 10 === 0) {
      // special lock floors: always need a key or code
      return (roll < 0.5)
        ? { type: GoalType.FIND_KEY, text:"Anahtar bul", done:false }
        : { type: GoalType.KEYPAD_CODE, text:"Şifre bul", done:false };
    }
    if (t < 0.35){
      if (roll < 0.55) return { type: GoalType.FIND_KEY, text:"Anahtar bul", done:false };
      return { type: GoalType.PULL_LEVER, text:"Kolu çek", done:false };
    }
    if (t < 0.72){
      if (roll < 0.40) return { type: GoalType.FIX_FUSE, text:"Sigorta onar", done:false };
      if (roll < 0.72) return { type: GoalType.KEYPAD_CODE, text:"Şifre bul", done:false };
      return { type: GoalType.PULL_LEVER, text:"Kolu çek", done:false };
    }
    // late game
    if (roll < 0.45) return { type: GoalType.KEYPAD_CODE, text:"Şifre bul", done:false };
    if (roll < 0.80) return { type: GoalType.FIX_FUSE, text:"Sigorta onar", done:false };
    return { type: GoalType.FIND_KEY, text:"Anahtar bul", done:false };
  }

  /* =========================
     Game state
  ========================= */
  const game = {
    running:false,
    floor:1,
    state:"menu", // menu, play, moving, fail, win
    t:0,
    lights:1,
    shake:0,
    room:null,
    pal:null,
    monster:null,
    goal:null,
    inventory:{
      fuse:false,
      noteCode:null
    },
    objects:{
      drawerTaken:false,
      fuseTaken:false,
      noteTaken:false,
      panelFixed:false,
      leverPulled:false,
      keypadSolved:false,
      keyFound:false
    }
  };

  const player = {
    x:0, y:0,
    vx:0,
    w:22, h:46,
    speed: 280,
    hp:3,
    keys:0,
    hidden:false,
    face:1,
    invuln:0
  };

  /* =========================
     Monsters (visible sprites)
     Types:
       PASSER: rush-like, crosses
       ROAMER: patrols in room, must avoid / hide
       LOOKER: eyes-like at top, punish movement
       WAVES: ambush-like multiple passes
  ========================= */
  const MonsterType = {
    NONE:"none",
    PASSER:"passer",
    ROAMER:"roamer",
    LOOKER:"looker",
    WAVES:"waves"
  };

  function monsterForFloor(floor){
    const rnd = seededRand(hashStr("MonType:"+floor));
    const name = monsterNameForFloor(floor);
    const t = clamp((floor-1)/99, 0, 1);

    // chance of monster this floor
    const have = rnd() < (0.55 + 0.30*t);
    if (!have) return { type:MonsterType.NONE, name };

    // weighted pick (later floors more intense)
    const wRoam = 0.30 + 0.12*t;
    const wPass = 0.32 + 0.10*t;
    const wLook = 0.20;
    const wWave = 0.18 + 0.14*t;
    const sum = wRoam+wPass+wLook+wWave;
    let r = rnd()*sum;

    let type = MonsterType.ROAMER;
    if ((r -= wRoam) < 0) type = MonsterType.ROAMER;
    else if ((r -= wPass) < 0) type = MonsterType.PASSER;
    else if ((r -= wLook) < 0) type = MonsterType.LOOKER;
    else type = MonsterType.WAVES;

    const baseSpeed = 170 + floor*1.4;
    const big = 1 + t*0.35;

    if (type === MonsterType.ROAMER){
      return {
        type, name,
        x: 0, y: 0, w: 44*big, h: 40*big,
        vx: (rnd()<0.5 ? -1 : 1) * (baseSpeed*0.8),
        state:"hunt",
        seen: false,
        help:"Odada dolaşıyor. Yaklaşma. Saklan (Space)."
      };
    }
    if (type === MonsterType.PASSER){
      return {
        type, name,
        x: -400, y: 0, w: 80*big, h: 52*big,
        speed: baseSpeed*3.6,
        phase:"warn",
        tt:0,
        help:"Geçiş geliyor. Dolaba gir (Space)."
      };
    }
    if (type === MonsterType.LOOKER){
      return {
        type, name,
        tt:0,
        duration: 2600 + Math.floor(rnd()*2600),
        help:"Hareket etme."
      };
    }
    return {
      type, name,
      phase:"warn",
      tt:0,
      passes: 2 + Math.floor(rnd()*3),
      passIndex:0,
      dir: 1,
      x:-500, y:0, w: 90*big, h: 58*big,
      speed: baseSpeed*3.0,
      help:"Geçişte saklan, arada çık."
    };
  }

  /* =========================
     Util: collisions
  ========================= */
  function rectsOverlap(a,b){
    return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
  }

  function near(x,y,r){
    const dx = player.x - x;
    const dy = player.y - y;
    return (dx*dx + dy*dy) <= r*r;
  }

  /* =========================
     Drawing helpers
  ========================= */
  function pxRect(x,y,w,h){ ctx.fillRect(x|0,y|0,w|0,h|0); }

  function vignette(intensity){
    const W=cv.width,H=cv.height;
    ctx.save();
    const g = ctx.createRadialGradient(W/2,H/2,50,W/2,H/2,Math.max(W,H)*0.62);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, `rgba(0,0,0,${clamp(intensity,0,0.92)})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  function drawTextBox(text, x, y, color){
    ctx.save();
    ctx.font = `${Math.max(14, Math.floor(Math.min(cv.width, cv.height)/68))}px ui-monospace, Menlo, Consolas, monospace`;
    const w = ctx.measureText(text).width;
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(x-10, y-22, w+20, 30);
    ctx.fillStyle = color || "rgba(255,255,255,.92)";
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  function drawPlayer(){
    if (player.hidden) return;
    const s = Math.max(2, Math.floor(Math.min(cv.width, cv.height)/360));
    const x = player.x, y = player.y;
    const ox = (x - 6*s)|0;
    const oy = (y - 16*s)|0;

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    pxRect(x - 12*s, y - 2*s, 24*s, 4*s);
    ctx.globalAlpha = 1;

    const skin = "#4b2f25";
    const shirt = "#3d7bff";
    const pants = "#1c2238";

    if (player.invuln > 0 && Math.floor(player.invuln/80)%2===0) ctx.globalAlpha = 0.45;

    ctx.fillStyle = pants;
    pxRect(ox + 4*s, oy + 12*s, 3*s, 4*s);
    pxRect(ox + 9*s, oy + 12*s, 3*s, 4*s);

    ctx.fillStyle = "#090b14";
    pxRect(ox + 3*s, oy + 15*s, 4*s, 2*s);
    pxRect(ox + 9*s, oy + 15*s, 4*s, 2*s);

    ctx.fillStyle = shirt;
    pxRect(ox + 4*s, oy + 7*s, 8*s, 6*s);

    ctx.fillStyle = shirt;
    pxRect(ox + 2*s, oy + 8*s, 2*s, 4*s);
    pxRect(ox + 12*s, oy + 8*s, 2*s, 4*s);

    ctx.fillStyle = skin;
    pxRect(ox + 2*s, oy + 11*s, 2*s, 2*s);
    pxRect(ox + 12*s, oy + 11*s, 2*s, 2*s);

    ctx.fillStyle = skin;
    pxRect(ox + 5*s, oy + 2*s, 6*s, 5*s);

    ctx.fillStyle = "#141018";
    pxRect(ox + 5*s, oy + 2*s, 6*s, 2*s);

    ctx.fillStyle = "#eaf2ff";
    pxRect(ox + 6*s, oy + 4*s, 1*s, 1*s);
    pxRect(ox + 9*s, oy + 4*s, 1*s, 1*s);

    ctx.fillStyle = "#0a0c12";
    const dir = player.face > 0 ? 1 : 0;
    pxRect(ox + (6+dir)*s, oy + 4*s, 1*s, 1*s);
    pxRect(ox + (9+dir)*s, oy + 4*s, 1*s, 1*s);

    ctx.fillStyle = "#0a0c12";
    pxRect(ox + 7*s, oy + 6*s, 2*s, 1*s);

    ctx.globalAlpha = 1;
  }

  function drawMonsterSprite(m){
    const R = game.room;
    const P = game.pal;
    const s = Math.max(2, Math.floor(Math.min(cv.width, cv.height)/420));

    if (m.type === MonsterType.LOOKER){
      // eyes at top, visible
      const W=cv.width,H=cv.height;
      const x=W/2, y=Math.floor(H*0.22);
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(255,255,255,.84)";
      pxRect(x-95, y-18, 72, 28);
      pxRect(x+23, y-18, 72, 28);
      ctx.fillStyle = "rgba(0,0,0,.86)";
      const p = player.face > 0 ? 12 : -12;
      pxRect(x-64 + p, y-10, 18, 18);
      pxRect(x+52 + p, y-10, 18, 18);
      ctx.restore();
      drawTextBox(m.name, Math.floor(x-120), Math.floor(H*0.12), P.warn);
      return;
    }

    // body (pixel blob)
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = P.warn;

    const step = Math.max(14, Math.floor(Math.min(cv.width, cv.height)/64));
    const cx = m.x, cy = m.y;
    const w = m.w, h = m.h;

    for (let yy=-h/2; yy<=h/2; yy+=step){
      for (let xx=-w/2; xx<=w/2; xx+=step){
        const d = (xx*xx)/(w*w) + (yy*yy)/(h*h);
        if (d < 0.24 + Math.random()*0.26) pxRect(cx+xx, cy+yy, step-2, step-2);
      }
    }

    // eyes on blob
    ctx.fillStyle = "rgba(255,255,255,.86)";
    pxRect(cx+18*s, cy-10*s, 12*s, 7*s);
    pxRect(cx+44*s, cy-10*s, 12*s, 7*s);
    ctx.fillStyle = "rgba(0,0,0,.90)";
    pxRect(cx+22*s, cy-8*s, 5*s, 5*s);
    pxRect(cx+48*s, cy-8*s, 5*s, 5*s);

    ctx.restore();

    // name tag
    drawTextBox(m.name, clamp(cx - 140, 20, cv.width-260), clamp(cy - m.h/2 - 18, 30, cv.height-30), P.warn);
  }

  function drawWarningStripes(alpha){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = game.pal.warn;
    for (let i=-240; i<W+240; i+=42){
      ctx.beginPath();
      ctx.moveTo(i,0);
      ctx.lineTo(i+20,0);
      ctx.lineTo(i+260,H);
      ctx.lineTo(i+240,H);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawRoom(){
    const R = game.room;
    const P = game.pal;
    const W = cv.width, H = cv.height;

    // colorful background
    ctx.fillStyle = P.bg1;
    ctx.fillRect(0,0,W,H);
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, P.bg1);
    g.addColorStop(1, P.bg2);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // neon grid
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = P.neon;
    const step = Math.max(22, Math.floor(Math.min(W,H)/32));
    for (let y=0; y<H; y+=step) pxRect(0,y,W,1);
    for (let x=0; x<W; x+=step) pxRect(x,0,1,H);
    ctx.globalAlpha = 1;

    // walls / floor
    const topY = Math.floor(H*0.10);
    ctx.fillStyle = P.wall;
    pxRect(R.leftWall, topY, R.rightWall-R.leftWall, R.floorY - topY);
    ctx.fillStyle = P.panel;
    pxRect(0, R.floorY, W, H - R.floorY);

    // pillars
    ctx.fillStyle = "rgba(0,0,0,.28)";
    pxRect(R.leftWall, topY, Math.floor(step*0.4), R.floorY-topY);
    pxRect(R.rightWall-Math.floor(step*0.4), topY, Math.floor(step*0.4), R.floorY-topY);

    // floor line
    ctx.fillStyle = "rgba(255,255,255,.12)";
    pxRect(R.leftWall, R.floorY, R.rightWall-R.leftWall, 2);

    // elevator frame
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(R.elevX, R.elevY, R.elevW, R.elevH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.elevX+8, R.elevY+8, R.elevW-16, R.elevH-16);

    // doors
    const open = (game.state==="moving") ? clamp(game.t/650,0,1) : 0;
    const gap = Math.floor(36*open);
    ctx.fillStyle = "rgba(255,255,255,.10)";
    pxRect(R.elevX + 14 - gap, R.elevY + Math.floor(R.elevH*0.22), R.doorW, R.doorH);
    pxRect(R.elevX + R.elevW - 14 - R.doorW + gap, R.elevY + Math.floor(R.elevH*0.22), R.doorW, R.doorH);

    // elevator panel light
    ctx.fillStyle = (game.goal && game.goal.done) ? P.good : P.neon;
    pxRect(R.elevX + R.elevW - 30, R.elevY + 18, 14, 14);

    // locker
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(R.lockerX, R.lockerY, R.lockerW, R.lockerH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.lockerX+6, R.lockerY+6, R.lockerW-12, R.lockerH-12);
    ctx.fillStyle = "rgba(104,255,177,.85)";
    pxRect(R.lockerX + R.lockerW - 14, R.lockerY + Math.floor(R.lockerH/2), 6, 6);

    // desk (key / fuse / clues spawn here sometimes)
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(R.deskX, R.deskY, R.deskW, R.deskH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.deskX+6, R.deskY+6, R.deskW-12, R.deskH-12);
    ctx.fillStyle = game.objects.drawerTaken ? "rgba(255,255,255,.25)" : "rgba(255,227,123,.85)";
    pxRect(R.deskX + R.deskW - 18, R.deskY + Math.floor(R.deskH/2), 10, 4);

    // fuse panel
    ctx.fillStyle = "rgba(0,0,0,.28)";
    pxRect(R.panelX, R.panelY, R.panelW, R.panelH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.panelX+6, R.panelY+6, R.panelW-12, R.panelH-12);
    ctx.fillStyle = game.objects.panelFixed ? P.good : P.warn;
    pxRect(R.panelX + R.panelW - 18, R.panelY + 14, 10, 10);

    // keypad (for code goal)
    ctx.fillStyle = "rgba(0,0,0,.30)";
    pxRect(R.keypadX, R.keypadY, R.keypadW, R.keypadH);
    ctx.fillStyle = "rgba(255,255,255,.10)";
    pxRect(R.keypadX+6, R.keypadY+6, R.keypadW-12, R.keypadH-12);
    ctx.fillStyle = game.objects.keypadSolved ? P.good : P.neon;
    pxRect(R.keypadX + 18, R.keypadY + 12, 20, 8);

    // lever
    ctx.fillStyle = "rgba(0,0,0,.30)";
    pxRect(R.leverX, R.leverY, R.leverW, R.leverH);
    ctx.fillStyle = game.objects.leverPulled ? P.good : P.neon;
    pxRect(R.leverX + 18, R.leverY + 10, 12, 54);

    // note (clue for keypad)
    ctx.fillStyle = game.objects.noteTaken ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.62)";
    pxRect(R.noteX, R.noteY, 34, 22);

    // labels
    ctx.globalAlpha = 0.80;
    ctx.fillStyle = P.neon;
    ctx.font = `${Math.max(12, Math.floor(Math.min(W,H)/78))}px system-ui, Arial`;
    ctx.fillText("Dolap (Space)", R.lockerX - 2, R.lockerY - 10);
    ctx.fillText("Çekmece / Eşya (W)", R.deskX, R.deskY - 10);
    ctx.fillText("Asansör (Enter)", R.elevX + 10, R.elevY + R.elevH + 18);
    ctx.fillText("Panel (W)", R.panelX, R.panelY - 10);
    ctx.fillText("Şifre Paneli (W)", R.keypadX - 10, R.keypadY - 10);
    ctx.fillText("Kol (W)", R.leverX - 10, R.leverY - 10);
    ctx.globalAlpha = 1;

    // hidden overlay
    if (player.hidden){
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "rgba(0,0,0,.78)";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      drawTextBox("Dolaptasın. Sessiz kal.", 24, 44, P.neon);
    }

    // top sign
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(0,0,0,.25)";
    pxRect(R.leftWall + 36, topY, 260, 30);
    ctx.fillStyle = "rgba(255,255,255,.85)";
    ctx.font = `${Math.max(14, Math.floor(Math.min(W,H)/60))}px ui-monospace, Menlo, Consolas, monospace`;
    ctx.fillText(`FLOOR ${game.floor}`, R.leftWall + 50, topY+22);
    ctx.globalAlpha = 1;
  }

  /* =========================
     Input
  ========================= */
  const keys = new Set();
  const pressed = new Set();

  window.addEventListener("keydown", (e)=>{
    const k = (e.key||"").toLowerCase();
    if (!keys.has(k)) pressed.add(k);
    keys.add(k);

    if (k === "escape" && game.running){
      toggleMenu();
    }

    if (["arrowleft","arrowright","arrowup"," ","spacebar"].includes(k) || e.key===" ") e.preventDefault();
  }, {passive:false});

  window.addEventListener("keyup", (e)=>{
    keys.delete((e.key||"").toLowerCase());
  });

  function isDown(k){ return keys.has(k); }
  function wasPressed(k){ return pressed.has(k); }

  /* =========================
     Interactions: goals / items
  ========================= */
  function resetObjects(){
    game.inventory.fuse = false;
    game.inventory.noteCode = null;

    game.objects.drawerTaken = false;
    game.objects.fuseTaken = false;
    game.objects.noteTaken = false;
    game.objects.panelFixed = false;
    game.objects.leverPulled = false;
    game.objects.keypadSolved = false;
    game.objects.keyFound = false;
  }

  function makeCodeForFloor(floor){
    const rnd = seededRand(hashStr("Code:"+floor));
    const d1 = 1 + Math.floor(rnd()*9);
    const d2 = Math.floor(rnd()*10);
    const d3 = Math.floor(rnd()*10);
    return ""+d1+d2+d3;
  }

  function tryInteract(){
    const R = game.room;

    // drawer / item pickup
    if (near(R.deskX + R.deskW/2, R.floorY - 10, 120)){
      if (!game.objects.drawerTaken){
        game.objects.drawerTaken = true;

        if (game.goal.type === GoalType.FIND_KEY && !game.objects.keyFound){
          game.objects.keyFound = true;
          game.goal.done = true;
          showToast("Anahtar bulundu. Asansör açıldı.", 2200);
        } else if (game.goal.type === GoalType.FIX_FUSE && !game.objects.fuseTaken){
          // 50% chance fuse is in drawer, otherwise somewhere else (note)
          const rnd = seededRand(hashStr("FusePlace:"+game.floor));
          if (rnd() < 0.55){
            game.objects.fuseTaken = true;
            game.inventory.fuse = true;
            showToast("Sigorta parçası bulundu. Panele git.", 2200);
          } else {
            showToast("Çekmece boş. Başka yerde olabilir.", 2000);
          }
        } else if (game.goal.type === GoalType.KEYPAD_CODE){
          // sometimes a hint piece appears in drawer
          const rnd = seededRand(hashStr("CodePlace:"+game.floor));
          if (rnd() < 0.45 && !game.objects.noteTaken){
            const code = makeCodeForFloor(game.floor);
            game.inventory.noteCode = code;
            game.objects.noteTaken = true;
            showToast("Not buldun: şifre " + code, 2600);
          } else {
            showToast("Çekmece: işe yarar bir şey yok.", 1800);
          }
        } else {
          // generic reward: extra key occasionally
          if (chance(0.18)){
            player.keys += 1;
            showToast("Yedek anahtar +1", 1600);
          } else {
            showToast("Çekmecede bir şey yok.", 1600);
          }
        }
      } else {
        showToast("Çekmece boş.", 1400);
      }
      syncUI();
      return;
    }

    // note pickup (clue)
    if (!game.objects.noteTaken && near(R.noteX + 18, R.noteY + 10, 90)){
      game.objects.noteTaken = true;
      const code = makeCodeForFloor(game.floor);
      game.inventory.noteCode = code;
      showToast("Not buldun: şifre " + code, 2600);
      syncUI();
      return;
    }

    // fuse panel fix
    if (near(R.panelX + R.panelW/2, R.panelY + R.panelH/2, 140)){
      if (game.goal.type !== GoalType.FIX_FUSE){
        showToast("Panel aktif değil.", 1400);
        return;
      }
      if (game.objects.panelFixed){
        showToast("Panel zaten onarıldı.", 1400);
        return;
      }
      if (!game.inventory.fuse){
        // if fuse not in drawer, allow it to be found as note pickup (fallback)
        const rnd = seededRand(hashStr("FuseFallback:"+game.floor));
        if (!game.objects.fuseTaken && rnd() < 0.35){
          game.objects.fuseTaken = true;
          game.inventory.fuse = true;
          showToast("Panel yanında sigorta buldun.", 1900);
        } else {
          showToast("Sigorta parçası gerekli.", 1700);
          return;
        }
      }
      game.objects.panelFixed = true;
      game.goal.done = true;
      showToast("Panel onarıldı. Asansör açıldı.", 2200);
      syncUI();
      return;
    }

    // lever pull
    if (near(R.leverX + R.leverW/2, R.leverY + R.leverH/2, 140)){
      if (game.goal.type !== GoalType.PULL_LEVER){
        showToast("Kol kilitli.", 1400);
        return;
      }
      if (!game.objects.leverPulled){
        game.objects.leverPulled = true;
        game.goal.done = true;
        showToast("Kolu çektin. Asansör açıldı.", 2200);
      } else {
        showToast("Kol zaten çekildi.", 1400);
      }
      syncUI();
      return;
    }

    // keypad solve
    if (near(R.keypadX + R.keypadW/2, R.keypadY + R.keypadH/2, 140)){
      if (game.goal.type !== GoalType.KEYPAD_CODE){
        showToast("Şifre paneli devre dışı.", 1400);
        return;
      }
      if (game.objects.keypadSolved){
        showToast("Şifre zaten girildi.", 1400);
        return;
      }
      if (!game.inventory.noteCode){
        showToast("Şifre ipucu gerekli. Not ara.", 2000);
        return;
      }
      game.objects.keypadSolved = true;
      game.goal.done = true;
      showToast("Şifre doğru. Asansör açıldı.", 2200);
      syncUI();
      return;
    }

    showToast("Etkileşim yok. Nesneye yaklaş.", 1300);
  }

  function toggleHide(){
    const R = game.room;
    if (!near(R.lockerX + R.lockerW/2, R.floorY - 10, 140)){
      showToast("Dolaba yaklaş.", 1300);
      return;
    }
    player.hidden = !player.hidden;
    showToast(player.hidden ? "Dolaba girdin." : "Dolaptan çıktın.", 1200);
  }

  function tryElevator(){
    const R = game.room;
    if (!near(R.elevX + R.elevW/2, R.floorY - 10, 190)){
      showToast("Asansöre yaklaş.", 1300);
      return;
    }
    if (!game.goal.done){
      showToast("Önce görevi bitir.", 1600);
      return;
    }
    // optional extra lock: every 10 floors also consumes a spare key if you have it
    if (game.floor % 10 === 0){
      if (player.keys <= 0){
        showToast("Yedek anahtar gerekli (çekmeceler).", 2000);
        return;
      }
      player.keys -= 1;
    }
    enterMoving();
  }

  /* =========================
     Damage / end
  ========================= */
  function damage(reason){
    if (player.invuln > 0) return;
    player.hp -= 1;
    player.invuln = 1200;
    game.shake = 1.0;
    game.lights = 0.62;
    showToast("Hasar: " + reason, 2200);
    if (player.hp <= 0) enterFail(reason);
    syncUI();
  }

  /* =========================
     Update monster behavior (visible)
  ========================= */
  function initMonsterPosition(){
    const R = game.room;
    const m = game.monster;
    if (!m || m.type === MonsterType.NONE) return;

    const midY = Math.floor(R.floorY - 120);
    if (m.type === MonsterType.ROAMER){
      const rnd = seededRand(hashStr("RoamPos:"+game.floor));
      m.x = Math.floor(lerp(R.leftWall+80, R.rightWall-80, rnd()));
      m.y = midY + Math.floor((rnd()*2-1)*50);
    }
    if (m.type === MonsterType.PASSER){
      m.x = -400;
      m.y = midY + 30;
    }
    if (m.type === MonsterType.WAVES){
      m.x = -500;
      m.y = midY + 30;
    }
  }

  function updateMonster(dt){
    const R = game.room;
    const m = game.monster;
    if (!m || m.type === MonsterType.NONE) return;

    // LOOKER: punish movement, visible eyes drawn
    if (m.type === MonsterType.LOOKER){
      m.tt += dt;
      game.lights = lerp(game.lights, 0.72, 0.05);
      if (Math.abs(player.vx) > 1) damage(m.name + " hareketini fark etti.");
      if (m.tt > m.duration){
        // ends naturally
        game.monster = null;
        showToast("Tehdit geçti.", 1500);
        uiMonster.textContent = "-";
      }
      return;
    }

    // PASSER: warning then pass across screen
    if (m.type === MonsterType.PASSER){
      m.tt += dt;

      if (m.phase === "warn"){
        game.lights = lerp(game.lights, 0.72, 0.04);
        drawWarningStripes(0.22); // drawn also in render; harmless call if missed, but we'll do in render too
        if (m.tt > 900){
          m.phase = "pass";
          m.tt = 0;
          m.x = -400;
          game.shake = 0.35;
          showToast("Geçiş geliyor: " + m.name, 1600);
        }
      } else if (m.phase === "pass"){
        game.lights = lerp(game.lights, 0.58, 0.06);
        m.x += m.speed * (dt/1000);
        game.shake = lerp(game.shake, 0.85, 0.06);

        const hit = { x: m.x - m.w/2, y: m.y - m.h/2, w: m.w, h: m.h };
        const pbox = { x: player.x - 12, y: player.y - player.h, w: 24, h: player.h };
        if (rectsOverlap(hit, pbox) && !player.hidden) damage(m.name + " yakaladı.");

        if (m.x > cv.width + 500){
          game.monster = null;
          showToast("Geçiş bitti.", 1400);
          uiMonster.textContent = "-";
          game.lights = lerp(game.lights, 1.0, 0.2);
          game.shake = lerp(game.shake, 0, 0.2);
        }
      }
      return;
    }

    // WAVES: multiple passes
    if (m.type === MonsterType.WAVES){
      m.tt += dt;

      if (m.phase === "warn"){
        game.lights = lerp(game.lights, 0.70, 0.05);
        if (m.tt > 900){
          m.phase = "pass";
          m.tt = 0;
          m.x = (m.dir>0) ? -500 : (cv.width + 500);
          game.shake = 0.45;
          showToast("Dalga başlıyor: " + m.name, 1700);
        }
      } else if (m.phase === "pass"){
        game.lights = lerp(game.lights, 0.55, 0.06);
        m.x += m.dir * m.speed * (dt/1000);
        game.shake = lerp(game.shake, 0.85, 0.06);

        const hit = { x: m.x - m.w/2, y: m.y - m.h/2, w: m.w, h: m.h };
        const pbox = { x: player.x - 12, y: player.y - player.h, w: 24, h: player.h };
        if (rectsOverlap(hit, pbox) && !player.hidden) damage(m.name + " yakaladı.");

        const outR = m.x > cv.width + 520;
        const outL = m.x < -520;
        if (outR || outL){
          m.phase = "quiet";
          m.tt = 0;
          m.dir *= -1;
          m.passIndex += 1;
          game.shake = 0.10;
          game.lights = 0.82;
          showToast("Sessizlik.", 1100);
        }
      } else if (m.phase === "quiet"){
        game.lights = lerp(game.lights, 0.88, 0.05);
        if (player.hidden && chance(0.0025 * dt)) damage(m.name + " sabırsızlandı.");
        if (m.tt > 850){
          if (m.passIndex >= m.passes){
            game.monster = null;
            showToast("Dalga bitti.", 1300);
            uiMonster.textContent = "-";
            game.lights = 1.0;
            game.shake = 0;
          } else {
            m.phase = "pass";
            m.tt = 0;
            m.x = (m.dir>0) ? -500 : (cv.width + 500);
            game.shake = 0.5;
          }
        }
      }
      return;
    }

    // ROAMER: patrols inside room, visible always
    if (m.type === MonsterType.ROAMER){
      // if player hides, roamer may linger
      const speedMul = player.hidden ? 0.55 : 1.0;
      m.x += m.vx * speedMul * (dt/1000);

      // bounce in room
      const minX = R.leftWall + 70;
      const maxX = R.rightWall - 70;
      if (m.x < minX){ m.x = minX; m.vx = Math.abs(m.vx); }
      if (m.x > maxX){ m.x = maxX; m.vx = -Math.abs(m.vx); }

      // slight vertical bob
      m.y = Math.floor(R.floorY - 140 + Math.sin((now()/500) + game.floor)*14);

      // detect collision
      const hit = { x: m.x - m.w/2, y: m.y - m.h/2, w: m.w, h: m.h };
      const pbox = { x: player.x - 12, y: player.y - player.h, w: 24, h: player.h };
      if (rectsOverlap(hit, pbox) && !player.hidden) damage(m.name + " yakaladı.");

      // light tension effect
      game.lights = lerp(game.lights, 0.84, 0.03);
      game.shake = lerp(game.shake, 0.10, 0.03);
      return;
    }
  }

  /* =========================
     Menu
  ========================= */
  const btnStart = document.getElementById("btnStart");
  const btnHow = document.getElementById("btnHow");
  const btnReset = document.getElementById("btnReset");
  const howPanel = document.getElementById("howPanel");

  btnHow.addEventListener("click", ()=> howPanel.classList.toggle("hide"));
  btnReset.addEventListener("click", ()=> hardReset());
  btnStart.addEventListener("click", ()=> startGame());

  function toggleMenu(){
    if (!game.running) return;
    const open = !menu.classList.contains("hide");
    if (open){
      menu.classList.add("hide");
      showToast("Devam", 900);
    } else {
      menu.classList.remove("hide");
      showToast("Menü", 900);
    }
  }

  /* =========================
     State transitions
  ========================= */
  function syncUI(){
    uiFloor.textContent = String(game.floor);
    uiHP.textContent = String(player.hp);
    uiKey.textContent = String(player.keys);
    uiGoal.textContent = game.goal ? game.goal.text + (game.goal.done ? " (bitti)" : "") : "-";
    uiMonster.textContent = (game.monster && game.monster.type !== MonsterType.NONE) ? game.monster.name : "-";
  }

  function enterFloor(floor){
    game.floor = clamp(floor, 1, 100);
    game.room = roomForFloor(game.floor);
    game.pal = paletteForFloor(game.floor);

    resetObjects();

    game.goal = goalForFloor(game.floor);
    if (game.goal.type === GoalType.NONE) game.goal.done = true;

    // spawn monster
    game.monster = monsterForFloor(game.floor);
    initMonsterPosition();

    // place player
    const R = game.room;
    player.x = clamp(R.leftWall + 160, R.leftWall+40, R.rightWall-40);
    player.y = R.floorY;
    player.vx = 0;
    player.hidden = false;

    game.lights = 1.0;
    game.shake = 0;
    game.state = "play";
    game.t = 0;

    if (game.monster && game.monster.type !== MonsterType.NONE){
      showToast("Tehdit: " + game.monster.name + "\n" + game.monster.help, 2800);
    } else {
      showToast("Bu kat sessiz. Görevi bitir.", 2000);
    }

    syncUI();
  }

  function enterMoving(){
    game.state = "moving";
    game.t = 0;
    game.shake = 0.6;
    game.lights = 0.90;
    showToast("Asansör hareket ediyor...", 1500);
    syncUI();
  }

  function enterFail(reason){
    game.state = "fail";
    game.t = 0;
    showToast("Oyun bitti: " + reason + "\nEsc: Menü", 4000);
    syncUI();
  }

  function enterWin(){
    game.state = "win";
    game.t = 0;
    showToast("100. kata ulaştın. Kazandın.", 4200);
    syncUI();
  }

  function startGame(){
    menu.classList.add("hide");
    hud.classList.remove("hide");
    game.running = true;
    player.hp = 3;
    player.keys = 0;
    player.invuln = 0;
    enterFloor(1);
    showToast("Başladı. 100. kata ulaş.", 1700);
  }

  function hardReset(){
    game.running = true;
    player.hp = 3;
    player.keys = 0;
    player.invuln = 0;
    enterFloor(1);
    menu.classList.remove("hide");
    showToast("Sıfırlandı.", 1200);
  }

  /* =========================
     Gameplay update/render
  ========================= */
  function update(dt){
    if (!game.running) return;

    if (toastTimer > 0){
      toastTimer -= dt;
      if (toastTimer <= 0) toast.classList.remove("show");
    }

    if (player.invuln > 0) player.invuln -= dt;

    if (game.state === "fail" || game.state === "win") {
      player.vx = 0;
      syncUI();
      return;
    }

    const R = game.room;

    // movement disabled in menu overlay but we keep game running; if menu open, just freeze
    const menuOpen = !menu.classList.contains("hide");
    let ax = 0;
    if (!menuOpen && !player.hidden){
      if (isDown("a") || isDown("arrowleft")) ax -= 1;
      if (isDown("d") || isDown("arrowright")) ax += 1;
    }

    player.vx = ax * player.speed;
    if (player.vx !== 0) player.face = player.vx > 0 ? 1 : -1;

    if (game.state === "play"){
      player.x += player.vx * (dt/1000);
      player.x = clamp(player.x, R.leftWall + 30, R.rightWall - 30);
      player.y = R.floorY;

      // interactions
      if (!menuOpen){
        if (wasPressed("w") || wasPressed("arrowup")) tryInteract();
        if (wasPressed(" ") || wasPressed("spacebar")) toggleHide();
        if (wasPressed("enter")) tryElevator();
      }

      // monster
      if (!menuOpen) updateMonster(dt);

      // ambient settle
      if (!game.monster || game.monster.type === MonsterType.NONE){
        game.lights = lerp(game.lights, 1.0, 0.02);
        game.shake = lerp(game.shake, 0, 0.03);
      }
    }

    if (game.state === "moving"){
      game.t += dt;
      // keep movement minimal
      player.vx = 0;

      game.lights = lerp(game.lights, 0.86, 0.03);
      game.shake = lerp(game.shake, 0.35, 0.04);

      if (game.t > 1200){
        const next = game.floor + 1;
        if (next >= 100){
          enterFloor(100);
          enterWin();
        } else {
          enterFloor(next);
        }
      }
    }

    syncUI();
  }

  function render(){
    if (!game.running) return;
    const W=cv.width,H=cv.height;

    // shake
    const sx = (Math.random()*2-1) * (game.shake*10);
    const sy = (Math.random()*2-1) * (game.shake*6);

    ctx.save();
    ctx.translate(sx, sy);

    drawRoom();

    // extra warning stripes if pass/waves warn
    if (game.monster){
      if (game.monster.type === MonsterType.PASSER && game.monster.phase === "warn") drawWarningStripes(0.26);
      if (game.monster.type === MonsterType.WAVES && game.monster.phase === "warn") drawWarningStripes(0.28);
    }

    // draw visible monster
    if (game.monster && game.monster.type !== MonsterType.NONE){
      const m = game.monster;
      if (m.type === MonsterType.ROAMER || m.type === MonsterType.PASSER || m.type === MonsterType.WAVES){
        // set y if not set
        if (!m.y) m.y = Math.floor(game.room.floorY - 120);
      }
      drawMonsterSprite(m);
    }

    drawPlayer();

    // lighting overlay
    ctx.save();
    const dark = clamp(1 - game.lights, 0, 0.90);
    ctx.fillStyle = `rgba(0,0,0,${dark})`;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    vignette(0.30 + (1-game.lights)*0.45);

    // simple end banners
    if (game.state === "fail") drawBanner("OYUN BİTTİ", "Esc: Menü");
    if (game.state === "win") drawBanner("KAZANDIN", "100. kat");

    ctx.restore();
  }

  function drawBanner(title, sub){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(0,0,0,.62)";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    const bw = Math.min(760, Math.floor(W*0.80));
    const bh = Math.min(240, Math.floor(H*0.34));
    const x = (W-bw)/2, y=(H-bh)/2;

    ctx.fillStyle = "rgba(10,14,26,.88)";
    pxRect(x,y,bw,bh);
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.strokeRect(x,y,bw,bh);

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = `${Math.max(28, Math.floor(Math.min(W,H)/24))}px ui-monospace, Menlo, Consolas, monospace`;
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (W-tw)/2, y + Math.floor(bh*0.48));

    ctx.fillStyle = game.pal ? game.pal.neon : "rgba(106,215,255,.9)";
    ctx.font = `${Math.max(14, Math.floor(Math.min(W,H)/56))}px system-ui, Arial`;
    const sw = ctx.measureText(sub).width;
    ctx.fillText(sub, (W-sw)/2, y + Math.floor(bh*0.68));
    ctx.restore();
  }

  /* =========================
     Main loop
  ========================= */
  let last = now();
  function frame(){
    const t = now();
    const dt = Math.min(33, t - last);
    last = t;

    update(dt);
    render();

    pressed.clear();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  /* =========================
     Menu controls
  ========================= */
  document.getElementById("btnHow").addEventListener("click", ()=>{
    document.getElementById("howPanel").classList.toggle("hide");
  });
  document.getElementById("btnReset").addEventListener("click", ()=> hardReset());
  document.getElementById("btnStart").addEventListener("click", ()=> startGame());

  // Start in menu
  hud.classList.remove("hide");
  showToast("Menü: Başlat ile oyna.", 1600);

})();
</script>
</body>
</html>

