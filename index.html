<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>The Elevator</title>
  <style>
    :root{
      --bg:#05060a;
      --fg:#eaf2ff;
      --muted:#a8b6c6;
      --glass: rgba(18, 24, 44, .72);
      --glass2: rgba(10, 14, 26, .78);
      --line: rgba(255,255,255,.10);
      --line2: rgba(255,255,255,.16);
      --good:#68ffb1;
      --bad:#ff4f7b;
      --blue:#6ad7ff;
      --yellow:#ffe37b;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    #app{height:100%; width:100%; overflow:hidden;}
    canvas{
      width:100vw; height:100vh;
      display:block;
      background:#02030a;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    .hud{
      position:fixed; left:14px; top:14px;
      display:flex; gap:10px; flex-wrap:wrap;
      z-index:20;
      user-select:none;
      pointer-events:none;
    }
    .chip{
      background:var(--glass);
      border:1px solid var(--line);
      border-radius:999px;
      padding:8px 12px;
      font-size:13px;
      letter-spacing:.2px;
      backdrop-filter: blur(10px);
    }
    .chip b{font-weight:800; color:var(--fg)}
    .toast{
      position:fixed; right:14px; top:14px;
      max-width:min(560px, calc(100vw - 28px));
      background:var(--glass2);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      line-height:1.35;
      z-index:30;
      opacity:0;
      transform: translateY(-8px);
      transition:.18s ease;
      user-select:none;
      pointer-events:none;
      backdrop-filter: blur(10px);
      white-space:pre-line;
    }
    .toast.show{opacity:1; transform:translateY(0);}

    .menu{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      z-index:50;
      background:
        radial-gradient(1000px 700px at 20% 20%, rgba(106,215,255,.18), transparent 60%),
        radial-gradient(900px 600px at 80% 70%, rgba(255,79,123,.14), transparent 55%),
        radial-gradient(800px 600px at 40% 90%, rgba(255,227,123,.10), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.65));
    }
    .card{
      width:min(760px, calc(100vw - 28px));
      background:rgba(10, 14, 26, .82);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:18px;
      box-shadow: 0 22px 80px rgba(0,0,0,.62);
      backdrop-filter: blur(12px);
    }
    .row{display:flex; gap:14px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .title{
      font-size:26px; font-weight:900; letter-spacing:.6px;
    }
    .sub{color:var(--muted); margin-top:6px; font-size:14px; line-height:1.45;}
    .grid{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:14px;
      margin-top:14px;
    }
    @media (max-width:860px){ .grid{grid-template-columns:1fr;} }
    .panel{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:16px;
      padding:14px;
    }
    .panel h3{margin:0 0 8px; font-size:14px; letter-spacing:.2px;}
    .panel p{margin:0; color:var(--muted); font-size:13px; line-height:1.45;}
    .kbd{
      display:inline-block;
      padding:2px 7px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      font-size:12px;
      margin:0 2px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;}
    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);
      color:var(--fg);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      font-size:13px;
      transition:.15s ease;
    }
    button:hover{transform: translateY(-1px); border-color: rgba(106,215,255,.38);}
    button:active{transform: translateY(0);}
    .danger{border-color: rgba(255,79,123,.34);}
    .danger:hover{border-color: rgba(255,79,123,.55);}
    .small{margin-top:10px; color:var(--muted); font-size:12px; line-height:1.45;}
    .hide{display:none!important;}
  </style>
</head>
<body>
<div id="app">
  <canvas id="cv" width="1280" height="720"></canvas>

  <div class="hud" id="hud">
    <div class="chip">Kat: <b id="uiFloor">1</b>/100</div>
    <div class="chip">Can: <b id="uiHP">3</b></div>
    <div class="chip">Anahtar: <b id="uiKey">0</b></div>
    <div class="chip">Olay: <b id="uiEvent">Yok</b></div>
    <div class="chip">Canavar: <b id="uiMonster">-</b></div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="menu" id="menu">
    <div class="card">
      <div class="row">
        <div>
          <div class="title">The Elevator</div>
          <div class="sub">
            2D pikselli asansör kaçış oyunu. 100. kata ulaş.<br>
            Her kat farklı ölçüde, her olay farklı canavar adıyla gelir.
          </div>
        </div>
        <div class="btns">
          <button id="btnStart">Başlat</button>
          <button id="btnHow">Kontroller</button>
          <button id="btnRestart" class="danger">Sıfırla</button>
        </div>
      </div>

      <div class="grid" id="howPanel" class="hide">
        <div class="panel">
          <h3>Kontroller</h3>
          <p>
            Hareket: <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">←</span><span class="kbd">→</span><br>
            Etkileşim: <span class="kbd">W</span> / <span class="kbd">↑</span><br>
            Saklan (dolap): <span class="kbd">Space</span><br>
            Asansör: <span class="kbd">Enter</span><br>
            Menü: <span class="kbd">Esc</span>
          </p>
          <div class="small">
            Her 10 katta bir asansör kilidi olabilir. Çekmeceden anahtar çıkar.
          </div>
        </div>
        <div class="panel">
          <h3>Olay Tipleri</h3>
          <p>
            Geçiş: saklanman gerekir.<br>
            Bakış: hareket etme, yön değiştirmeyi azalt.<br>
            Dolap: dolapta fazla kalırsan dışarı atar.<br>
            Dalga: birden fazla geçiş olur, aralarda çık.
          </p>
        </div>
      </div>

      <div class="small">
        Not: Tarayıcı gerçek tam ekran için izin ister. İstersen F11 kullan.
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* =========================
     Canvas / Resize
  ========================= */
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const uiFloor = document.getElementById("uiFloor");
  const uiHP = document.getElementById("uiHP");
  const uiKey = document.getElementById("uiKey");
  const uiEvent = document.getElementById("uiEvent");
  const uiMonster = document.getElementById("uiMonster");

  const menu = document.getElementById("menu");
  const hud = document.getElementById("hud");
  const toast = document.getElementById("toast");

  function fitCanvas() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    cv.width = w;
    cv.height = h;
  }
  window.addEventListener("resize", fitCanvas);
  fitCanvas();

  /* =========================
     Helpers
  ========================= */
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b+1));
  const chance = (p)=>Math.random()<p;

  function now(){ return performance.now(); }

  function hashStr(s){
    // simple deterministic hash for names
    let h=2166136261>>>0;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h>>>0;
  }

  function seededRand(seed){
    // xorshift32
    let x = seed>>>0;
    return () => {
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    };
  }

  /* =========================
     Toast
  ========================= */
  let toastTimer = 0;
  function showToast(text, ms=2400){
    toast.textContent = text;
    toast.classList.add("show");
    toastTimer = ms;
  }

  /* =========================
     Input
  ========================= */
  const keys = new Set();
  const pressed = new Set();

  window.addEventListener("keydown", (e)=>{
    const k = (e.key || "").toLowerCase();
    if (!keys.has(k)) pressed.add(k);
    keys.add(k);

    if (k === "escape") {
      // toggle menu
      if (game.running) toggleMenu();
    }

    // block scrolling
    if (["arrowleft","arrowright","arrowup"," ","spacebar"].includes(k) || e.key === " ") e.preventDefault();
  }, {passive:false});

  window.addEventListener("keyup", (e)=>{
    keys.delete((e.key||"").toLowerCase());
  });

  function isDown(k){ return keys.has(k); }
  function wasPressed(k){ return pressed.has(k); }

  /* =========================
     Monster Name Generator
     Each floor -> unique name (deterministic)
  ========================= */
  const namePartsA = ["Noct","Vanta","Ruin","Gloom","Sable","Grim","Dread","Vile","Murk","Void","Shade","Crypt","Feral","Cinder","Hollow","Wraith"];
  const namePartsB = ["walker","seer","runner","mangler","whisper","stalker","crawler","drifter","lurker","binder","shiver","harrow","ripper","sunder","echo","warden"];
  const namePartsC = ["-I","-II","-III","-IV","-V","-VI","-VII","-VIII","-IX","-X"];

  function monsterNameForFloor(floor){
    const seed = hashStr("TheElevator:"+floor);
    const rnd = seededRand(seed);
    const a = namePartsA[Math.floor(rnd()*namePartsA.length)];
    const b = namePartsB[Math.floor(rnd()*namePartsB.length)];
    const c = namePartsC[Math.floor(rnd()*namePartsC.length)];
    // ensure visually distinct
    return a + b + c;
  }

  /* =========================
     Procedural Room per Floor
     Different widths and object positions
  ========================= */
  function roomForFloor(floor){
    const seed = hashStr("Room:"+floor);
    const rnd = seededRand(seed);

    // dynamic world bounds inside screen
    const W = cv.width, H = cv.height;
    const floorY = Math.floor(H * (0.80 + (rnd()*0.03 - 0.015)));

    // room width ratio changes per floor
    const minRatio = 0.58;
    const maxRatio = 0.86;
    const ratio = minRatio + (maxRatio-minRatio) * (0.15 + 0.85*rnd());
    const roomW = Math.floor(W * ratio);

    const leftWall = Math.floor((W - roomW)/2);
    const rightWall = leftWall + roomW;

    const elevW = Math.floor(120 + rnd()*90);
    const elevH = Math.floor(H * (0.32 + rnd()*0.08));
    const elevX = Math.floor(rightWall - elevW - (40 + rnd()*40));
    const elevY = Math.floor(floorY - elevH - (40 + rnd()*35));

    const lockerW = Math.floor(62 + rnd()*40);
    const lockerH = Math.floor(H * (0.18 + rnd()*0.07));
    const lockerX = Math.floor(leftWall + (40 + rnd()*90));
    const lockerY = Math.floor(floorY - lockerH);

    const deskW = Math.floor(110 + rnd()*110);
    const deskH = Math.floor(44 + rnd()*46);
    const deskX = Math.floor(leftWall + roomW*(0.36 + rnd()*0.18));
    const deskY = Math.floor(floorY - deskH);

    return {
      W, H,
      floorY,
      leftWall,
      rightWall,
      elevX, elevY, elevW, elevH,
      doorW: Math.floor(elevW * 0.42),
      doorH: Math.floor(elevH * 0.62),
      lockerX, lockerY, lockerW, lockerH,
      deskX, deskY, deskW, deskH
    };
  }

  /* =========================
     Game State
  ========================= */
  const game = {
    running: false,
    pausedMenu: true,
    floor: 1,
    state: "menu", // menu, ready, event, moving, fail, win
    t: 0,
    lights: 1,
    shake: 0,
    event: null,
    room: null,
    palette: null
  };

  const player = {
    x: 0, y: 0,
    vx: 0,
    w: 22,
    h: 46,
    speed: 260,
    hp: 3,
    keys: 0,
    hidden: false,
    face: 1,
    invuln: 0
  };

  const loot = { drawerTaken:false };

  /* =========================
     Color Palettes per Floor
  ========================= */
  function paletteForFloor(floor){
    const seed = hashStr("Pal:"+floor);
    const rnd = seededRand(seed);

    // vivid but dark-friendly
    const hues = [195, 320, 42, 265, 155, 10, 230, 285];
    const baseHue = hues[Math.floor(rnd()*hues.length)];
    const accentHue = (baseHue + 75 + Math.floor(rnd()*60)) % 360;

    const sat1 = 72 + Math.floor(rnd()*18);
    const sat2 = 70 + Math.floor(rnd()*20);

    const bg1 = `hsl(${baseHue} ${sat1}% ${10 + Math.floor(rnd()*6)}%)`;
    const bg2 = `hsl(${(baseHue+20)%360} ${sat1}% ${6 + Math.floor(rnd()*5)}%)`;
    const wall = `hsl(${(baseHue+5)%360} ${sat1}% ${14 + Math.floor(rnd()*5)}%)`;
    const panel = `hsl(${(baseHue+15)%360} ${sat1}% ${18 + Math.floor(rnd()*5)}%)`;
    const neon = `hsl(${accentHue} ${sat2}% ${62 + Math.floor(rnd()*10)}%)`;
    const warn = `hsl(${(accentHue+170)%360} ${85}% ${60}%)`;

    return { bg1, bg2, wall, panel, neon, warn };
  }

  /* =========================
     Events (Doors-like)
  ========================= */
  const EventType = {
    NONE:"none",
    PASS:"pass",     // rush-like
    LOOK:"look",     // eyes-like
    LOCKER:"locker", // hide-like
    WAVES:"waves"    // ambush-like
  };

  function newEventForFloor(floor){
    const seed = hashStr("Evt:"+floor);
    const rnd = seededRand(seed);

    // event chance grows
    const t = clamp((floor-1)/99, 0, 1);
    const have = rnd() < (0.62 + 0.25*t);
    if (!have) return { type: EventType.NONE };

    const wPass = 0.38 + 0.10*t;
    const wLook = 0.26;
    const wLock = 0.16 + 0.10*t;
    const wWave = 0.20 + 0.10*t;
    const sum = wPass+wLook+wLock+wWave;
    let r = rnd()*sum;

    let type = EventType.PASS;
    if ((r -= wPass) < 0) type = EventType.PASS;
    else if ((r -= wLook) < 0) type = EventType.LOOK;
    else if ((r -= wLock) < 0) type = EventType.LOCKER;
    else type = EventType.WAVES;

    const monster = monsterNameForFloor(floor);

    if (type === EventType.PASS) return {
      type, monster,
      phase:"warn",
      t:0,
      x:-240,
      speed: 760 + floor*2.2,
      help:"Geçiş geliyor. Dolaba gir (Space)."
    };

    if (type === EventType.LOOK) return {
      type, monster,
      t:0,
      duration: 2600 + Math.floor(rnd()*2200),
      help:"Hareket etme. Kıpırdama."
    };

    if (type === EventType.LOCKER) return {
      type, monster,
      t:0,
      duration: 2600 + Math.floor(rnd()*2600),
      help:"Dolapta çok uzun kalma."
    };

    // WAVES
    return {
      type, monster,
      phase:"warn",
      t:0,
      passes: 2 + Math.floor(rnd()*3),
      passIndex: 0,
      dir: 1,
      x: -300,
      speed: 640 + floor*1.6,
      help:"Geçişte saklan, durulunca çık."
    };
  }

  /* =========================
     Interactions
  ========================= */
  function near(x,y,r){
    const dx = player.x - x;
    const dy = player.y - y;
    return (dx*dx + dy*dy) <= r*r;
  }

  function tryDrawer(){
    if (game.state !== "ready" && game.state !== "event") return;
    if (loot.drawerTaken) { showToast("Çekmece boş."); return; }
    const R = game.room;
    if (!near(R.deskX + R.deskW/2, R.floorY - 10, 110)) { showToast("Çekmeceye yaklaş."); return; }
    loot.drawerTaken = true;
    player.keys += 1;
    showToast("Anahtar +1");
  }

  function tryElevator(){
    if (game.state !== "ready") return;
    const R = game.room;
    if (!near(R.elevX + R.elevW/2, R.floorY - 10, 160)) { showToast("Asansöre yaklaş."); return; }

    const needKey = (game.floor % 10 === 0);
    if (needKey && player.keys <= 0) {
      showToast("Asansör kilitli. Anahtar gerekli.");
      return;
    }
    if (needKey) player.keys -= 1;
    enterMoving();
  }

  function toggleHide(){
    if (game.state === "moving" || game.state === "fail" || game.state === "win") return;
    const R = game.room;
    if (!near(R.lockerX + R.lockerW/2, R.floorY - 10, 130)) { showToast("Dolaba yaklaş."); return; }
    player.hidden = !player.hidden;
    showToast(player.hidden ? "Dolaba girdin." : "Dolaptan çıktın.", 1400);
  }

  /* =========================
     State transitions
  ========================= */
  function syncUI(){
    uiFloor.textContent = String(game.floor);
    uiHP.textContent = String(player.hp);
    uiKey.textContent = String(player.keys);
    uiEvent.textContent =
      game.state === "event" ? "Var" :
      game.state === "moving" ? "Asansör" :
      game.state === "fail" ? "Bitti" :
      game.state === "win" ? "Kazandı" : "Yok";
    uiMonster.textContent = (game.event && game.event.type !== EventType.NONE) ? game.event.monster : "-";
  }

  function damage(reason){
    if (player.invuln > 0) return;
    player.hp -= 1;
    player.invuln = 1200;
    game.shake = 1.0;
    game.lights = 0.62;
    showToast("Hasar: " + reason, 2200);
    if (player.hp <= 0) enterFail(reason);
    syncUI();
  }

  function enterFloor(f){
    game.floor = clamp(f, 1, 100);
    game.room = roomForFloor(game.floor);
    game.palette = paletteForFloor(game.floor);

    // reset objects
    loot.drawerTaken = false;
    player.hidden = false;

    // place player
    player.x = clamp(game.room.leftWall + 160, game.room.leftWall+40, game.room.rightWall-40);
    player.y = game.room.floorY;
    player.vx = 0;

    game.lights = 1.0;
    game.shake = 0;

    game.event = newEventForFloor(game.floor);
    if (game.event.type === EventType.NONE){
      game.state = "ready";
      showToast("Kat sakin. Çekmeceyi kontrol et.", 2200);
    } else {
      game.state = "event";
      showToast("Olay: " + game.event.monster + "\n" + game.event.help, 2800);
    }
    syncUI();
  }

  function enterMoving(){
    game.state = "moving";
    game.t = 0;
    game.shake = 0.6;
    game.lights = 0.9;
    showToast("Asansör hareket ediyor...", 1600);
    syncUI();
  }

  function enterFail(reason){
    game.state = "fail";
    game.t = 0;
    showToast("Oyun bitti: " + reason + "\nMenü için Esc, sıfırlamak için menüden Sıfırla.", 4000);
    syncUI();
  }

  function enterWin(){
    game.state = "win";
    game.t = 0;
    showToast("100. kata ulaştın. Kazandın.\nDevamını istersek yeni kat tipleri ekleriz.", 4500);
    syncUI();
  }

  /* =========================
     Drawing (pixel-ish)
  ========================= */
  function pxRect(x,y,w,h){ ctx.fillRect(x|0,y|0,w|0,h|0); }

  function vignette(intensity){
    const W=cv.width,H=cv.height;
    ctx.save();
    const g = ctx.createRadialGradient(W/2,H/2,50,W/2,H/2,Math.max(W,H)*0.62);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, `rgba(0,0,0,${clamp(intensity,0,0.9)})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  function drawPlayer(){
    if (player.hidden) return;

    const s = Math.max(2, Math.floor(Math.min(cv.width, cv.height) / 360));
    const x = player.x, y = player.y;

    // shadow
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "#000";
    pxRect(x - 12*s, y - 2*s, 24*s, 4*s);
    ctx.globalAlpha = 1;

    const ox = (x - 6*s)|0;
    const oy = (y - 16*s)|0;

    const skin = "#4b2f25";
    const shirt = "#3d7bff";
    const pants = "#1c2238";

    if (player.invuln > 0 && Math.floor(player.invuln/80)%2===0) ctx.globalAlpha = 0.45;

    // legs
    ctx.fillStyle = pants;
    pxRect(ox + 4*s, oy + 12*s, 3*s, 4*s);
    pxRect(ox + 9*s, oy + 12*s, 3*s, 4*s);

    // shoes
    ctx.fillStyle = "#090b14";
    pxRect(ox + 3*s, oy + 15*s, 4*s, 2*s);
    pxRect(ox + 9*s, oy + 15*s, 4*s, 2*s);

    // torso
    ctx.fillStyle = shirt;
    pxRect(ox + 4*s, oy + 7*s, 8*s, 6*s);

    // arms
    ctx.fillStyle = shirt;
    pxRect(ox + 2*s, oy + 8*s, 2*s, 4*s);
    pxRect(ox + 12*s, oy + 8*s, 2*s, 4*s);

    // hands
    ctx.fillStyle = skin;
    pxRect(ox + 2*s, oy + 11*s, 2*s, 2*s);
    pxRect(ox + 12*s, oy + 11*s, 2*s, 2*s);

    // head
    ctx.fillStyle = skin;
    pxRect(ox + 5*s, oy + 2*s, 6*s, 5*s);

    // hair
    ctx.fillStyle = "#141018";
    pxRect(ox + 5*s, oy + 2*s, 6*s, 2*s);

    // eyes
    ctx.fillStyle = "#eaf2ff";
    pxRect(ox + 6*s, oy + 4*s, 1*s, 1*s);
    pxRect(ox + 9*s, oy + 4*s, 1*s, 1*s);

    // pupils direction
    ctx.fillStyle = "#0a0c12";
    const dir = player.face > 0 ? 1 : 0;
    pxRect(ox + (6+dir)*s, oy + 4*s, 1*s, 1*s);
    pxRect(ox + (9+dir)*s, oy + 4*s, 1*s, 1*s);

    // mouth
    ctx.fillStyle = "#0a0c12";
    pxRect(ox + 7*s, oy + 6*s, 2*s, 1*s);

    ctx.globalAlpha = 1;
  }

  function drawRoom(){
    const R = game.room;
    const P = game.palette;
    const W = cv.width, H = cv.height;

    // colorful background
    ctx.fillStyle = P.bg1;
    ctx.fillRect(0,0,W,H);
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, P.bg1);
    g.addColorStop(1, P.bg2);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // neon grid
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = P.neon;
    const step = Math.max(22, Math.floor(Math.min(W,H)/32));
    for (let y=0; y<H; y+=step) pxRect(0,y,W,1);
    for (let x=0; x<W; x+=step) pxRect(x,0,1,H);
    ctx.globalAlpha = 1;

    // walls and floor
    ctx.fillStyle = P.wall;
    pxRect(R.leftWall, Math.floor(H*0.10), R.rightWall-R.leftWall, R.floorY - Math.floor(H*0.10));
    ctx.fillStyle = P.panel;
    pxRect(0, R.floorY, W, H - R.floorY);

    // pillars
    ctx.fillStyle = "rgba(0,0,0,.28)";
    pxRect(R.leftWall, Math.floor(H*0.10), Math.floor(step*0.4), R.floorY - Math.floor(H*0.10));
    pxRect(R.rightWall - Math.floor(step*0.4), Math.floor(H*0.10), Math.floor(step*0.4), R.floorY - Math.floor(H*0.10));

    // floor line
    ctx.fillStyle = "rgba(255,255,255,.12)";
    pxRect(R.leftWall, R.floorY, R.rightWall-R.leftWall, 2);

    // elevator
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(R.elevX, R.elevY, R.elevW, R.elevH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.elevX+8, R.elevY+8, R.elevW-16, R.elevH-16);

    const open = (game.state === "moving") ? clamp(game.t/650,0,1) : 0;
    const gap = Math.floor(36 * open);
    ctx.fillStyle = "rgba(255,255,255,.10)";
    pxRect(R.elevX + 14 - gap, R.elevY + Math.floor(R.elevH*0.22), R.doorW, R.doorH);
    pxRect(R.elevX + R.elevW - 14 - R.doorW + gap, R.elevY + Math.floor(R.elevH*0.22), R.doorW, R.doorH);

    // elevator panel light
    ctx.fillStyle = P.neon;
    pxRect(R.elevX + R.elevW - 30, R.elevY + 18, 14, 14);

    // locker
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(R.lockerX, R.lockerY, R.lockerW, R.lockerH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.lockerX+6, R.lockerY+6, R.lockerW-12, R.lockerH-12);
    ctx.fillStyle = "rgba(104,255,177,.85)";
    pxRect(R.lockerX + R.lockerW - 14, R.lockerY + Math.floor(R.lockerH/2), 6, 6);

    // desk
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect(R.deskX, R.deskY, R.deskW, R.deskH);
    ctx.fillStyle = "rgba(255,255,255,.08)";
    pxRect(R.deskX+6, R.deskY+6, R.deskW-12, R.deskH-12);

    // drawer knob
    ctx.fillStyle = loot.drawerTaken ? "rgba(255,255,255,.25)" : "rgba(255,227,123,.85)";
    pxRect(R.deskX + R.deskW - 18, R.deskY + Math.floor(R.deskH/2), 10, 4);

    // sign
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(0,0,0,.25)";
    pxRect(R.leftWall + 36, Math.floor(H*0.12), 220, 30);
    ctx.fillStyle = "rgba(255,255,255,.82)";
    ctx.font = `${Math.max(14, Math.floor(Math.min(W,H)/60))}px ui-monospace, Menlo, Consolas, monospace`;
    ctx.fillText(`FLOOR ${game.floor}`, R.leftWall + 50, Math.floor(H*0.12)+22);
    ctx.globalAlpha = 1;

    // hint labels
    ctx.globalAlpha = 0.72;
    ctx.fillStyle = P.neon;
    ctx.font = `${Math.max(12, Math.floor(Math.min(W,H)/78))}px system-ui, Arial`;
    ctx.fillText("Asansör (Enter)", R.elevX + 14, R.elevY + R.elevH + 18);
    ctx.fillText("Dolap (Space)", R.lockerX - 2, R.lockerY - 10);
    ctx.fillText("Çekmece (W)", R.deskX + 10, R.deskY - 10);
    ctx.globalAlpha = 1;

    // hidden overlay
    if (player.hidden){
      ctx.globalAlpha = 0.55;
      ctx.fillStyle = "rgba(0,0,0,.75)";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
      drawTextCenter("Dolaptasın. Sessiz kal.", Math.floor(H*0.16), P.neon);
    }
  }

  function drawTextCenter(text, y, color){
    const W=cv.width;
    ctx.save();
    ctx.font = `${Math.max(16, Math.floor(Math.min(cv.width, cv.height)/48))}px ui-monospace, Menlo, Consolas, monospace`;
    const w = ctx.measureText(text).width;
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(0,0,0,.35)";
    pxRect((W-w)/2 - 12, y - 26, w + 24, 34);
    ctx.fillStyle = color || "rgba(255,255,255,.92)";
    ctx.fillText(text, (W-w)/2, y);
    ctx.restore();
  }

  function drawWarningStripes(alpha){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = game.palette.warn;
    for (let i=-240; i<W+240; i+=42){
      ctx.beginPath();
      ctx.moveTo(i,0);
      ctx.lineTo(i+20,0);
      ctx.lineTo(i+260,H);
      ctx.lineTo(i+240,H);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawEntityBlob(x,y,w,h){
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = game.palette.warn;
    const step = Math.max(14, Math.floor(Math.min(cv.width, cv.height)/64));
    for (let yy=-h/2; yy<=h/2; yy+=step){
      for (let xx=-w/2; xx<=w/2; xx+=step){
        const d = (xx*xx)/(w*w) + (yy*yy)/(h*h);
        if (d < 0.22 + Math.random()*0.28) pxRect(x+xx, y+yy, step-2, step-2);
      }
    }
    // eyes
    ctx.fillStyle = "rgba(255,255,255,.85)";
    pxRect(x+18, y-10, 12, 7);
    pxRect(x+44, y-10, 12, 7);
    ctx.fillStyle = "rgba(0,0,0,.88)";
    pxRect(x+22, y-8, 5, 5);
    pxRect(x+48, y-8, 5, 5);
    ctx.restore();
  }

  function drawEyes(){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.globalAlpha = 0.92;
    const x=W/2, y=Math.floor(H*0.22);
    ctx.fillStyle = "rgba(255,255,255,.80)";
    pxRect(x-95, y-18, 72, 28);
    pxRect(x+23, y-18, 72, 28);
    ctx.fillStyle = "rgba(0,0,0,.85)";
    const p = player.face > 0 ? 12 : -12;
    pxRect(x-64 + p, y-10, 18, 18);
    pxRect(x+52 + p, y-10, 18, 18);
    ctx.restore();

    drawTextCenter("Dur. Kıpırdama.", Math.floor(H*0.16), game.palette.neon);
  }

  /* =========================
     Event logic
  ========================= */
  function updateEvent(dt){
    const e = game.event;
    if (!e || e.type === EventType.NONE) return;

    const W=cv.width,H=cv.height;

    if (e.type === EventType.PASS){
      e.t += dt;
      if (e.phase === "warn"){
        game.lights = lerp(game.lights, 0.72, 0.04);
        if (e.t > 900){
          e.phase = "pass";
          e.t = 0;
          e.x = -260;
          game.shake = 0.35;
        }
      } else if (e.phase === "pass"){
        game.lights = lerp(game.lights, 0.58, 0.06);
        e.x += e.speed * (dt/1000);
        game.shake = lerp(game.shake, 0.85, 0.06);

        const hit = {x:e.x, y:Math.floor(H*0.48), w:260, h:140};
        const px = player.x-10, py = player.y-player.h;
        const overlap = !(px+20 < hit.x || px > hit.x+hit.w || py+player.h < hit.y || py > hit.y+hit.h);
        if (overlap && !player.hidden) damage(e.monster + " yakaladı.");
        if (e.x > W + 320){
          game.event = null;
          game.state = "ready";
          game.lights = 1;
          game.shake = 0;
          showToast("Geçiş bitti.", 1600);
        }
      }
    }

    if (e.type === EventType.LOOK){
      e.t += dt;
      game.lights = lerp(game.lights, 0.72, 0.05);

      const moving = Math.abs(player.vx) > 1;
      if (moving) damage(e.monster + " hareketini fark etti.");
      if (e.t > e.duration){
        game.event = null;
        game.state = "ready";
        game.lights = 1;
        showToast("Bakış bitti.", 1500);
      }
    }

    if (e.type === EventType.LOCKER){
      e.t += dt;
      game.lights = lerp(game.lights, 0.82, 0.05);

      if (player.hidden && e.t > e.duration*0.65){
        player.hidden = false;
        damage(e.monster + " dolabı zorladı.");
      }
      if (e.t > e.duration){
        game.event = null;
        game.state = "ready";
        game.lights = 1;
        showToast("Dolap baskısı geçti.", 1500);
      }
    }

    if (e.type === EventType.WAVES){
      e.t += dt;

      if (e.phase === "warn"){
        game.lights = lerp(game.lights, 0.7, 0.05);
        if (e.t > 900){
          e.phase = "pass";
          e.t = 0;
          e.x = (e.dir>0) ? -320 : (W+320);
          game.shake = 0.45;
        }
      } else if (e.phase === "pass"){
        game.lights = lerp(game.lights, 0.55, 0.06);
        e.x += e.dir * e.speed * (dt/1000);
        game.shake = lerp(game.shake, 0.85, 0.06);

        const hit = {x:e.x, y:Math.floor(H*0.48), w:280, h:150};
        const px = player.x-10, py = player.y-player.h;
        const overlap = !(px+20 < hit.x || px > hit.x+hit.w || py+player.h < hit.y || py > hit.y+hit.h);
        if (overlap && !player.hidden) damage(e.monster + " yakaladı.");

        const outRight = e.x > W+360;
        const outLeft  = e.x < -360;
        if (outRight || outLeft){
          e.phase = "quiet";
          e.t = 0;
          e.dir *= -1;
          e.passIndex += 1;
          game.shake = 0.10;
          game.lights = 0.82;
          showToast("Sessizlik. Kısa sürer.", 1200);
        }
      } else if (e.phase === "quiet"){
        game.lights = lerp(game.lights, 0.88, 0.05);
        if (player.hidden && chance(0.0025 * dt)) damage(e.monster + " sabırsızlandı.");
        if (e.t > 850){
          if (e.passIndex >= e.passes){
            game.event = null;
            game.state = "ready";
            game.lights = 1;
            game.shake = 0;
            showToast("Dalga bitti.", 1400);
          } else {
            e.phase = "pass";
            e.t = 0;
            e.x = (e.dir>0) ? -320 : (W+320);
            game.shake = 0.5;
          }
        }
      }
    }
  }

  function drawEvent(){
    const e = game.event;
    if (!e || e.type === EventType.NONE) return;

    const W=cv.width,H=cv.height;

    if (e.type === EventType.PASS){
      if (e.phase === "warn") drawWarningStripes(0.26);
      if (e.phase === "pass") drawEntityBlob(e.x, Math.floor(H*0.60), 260, 130);
      drawTextCenter(e.monster, Math.floor(H*0.12), game.palette.warn);
    }

    if (e.type === EventType.LOOK){
      drawEyes();
      drawTextCenter(e.monster, Math.floor(H*0.12), game.palette.warn);
    }

    if (e.type === EventType.LOCKER){
      drawWarningStripes(0.16);
      drawTextCenter(e.monster, Math.floor(H*0.12), game.palette.warn);
    }

    if (e.type === EventType.WAVES){
      if (e.phase === "warn") drawWarningStripes(0.28);
      if (e.phase === "pass") drawEntityBlob(e.x, Math.floor(H*0.60), 280, 140);
      if (e.phase === "quiet") drawTextCenter("Sessizlik. Şimdi hareket et.", Math.floor(H*0.16), game.palette.neon);
      drawTextCenter(e.monster, Math.floor(H*0.12), game.palette.warn);
    }
  }

  /* =========================
     Update / Render loop
  ========================= */
  let last = now();

  function update(dt){
    if (!game.running) return;

    if (toastTimer > 0){
      toastTimer -= dt;
      if (toastTimer <= 0) toast.classList.remove("show");
    }

    if (player.invuln > 0) player.invuln -= dt;

    if (game.state === "fail" || game.state === "win") {
      player.vx = 0;
      return;
    }

    // movement
    let ax = 0;
    if (!player.hidden){
      if (isDown("a") || isDown("arrowleft")) ax -= 1;
      if (isDown("d") || isDown("arrowright")) ax += 1;
    }
    player.vx = ax * player.speed;
    if (player.vx !== 0) player.face = player.vx > 0 ? 1 : -1;

    // update position within room bounds
    const R = game.room;
    player.x += player.vx * (dt/1000);
    player.x = clamp(player.x, R.leftWall + 30, R.rightWall - 30);
    player.y = R.floorY;

    // interactions
    if (wasPressed("w") || wasPressed("arrowup")) tryDrawer();
    if (wasPressed(" ") || wasPressed("spacebar")) toggleHide();
    if (wasPressed("enter")) tryElevator();

    // state logic
    game.t += dt;

    if (game.state === "event") updateEvent(dt);

    if (game.state === "ready"){
      game.lights = lerp(game.lights, 1.0, 0.02);
      game.shake = lerp(game.shake, 0, 0.03);
    }

    if (game.state === "moving"){
      game.lights = lerp(game.lights, 0.86, 0.03);
      game.shake = lerp(game.shake, 0.35, 0.04);
      if (game.t > 1200){
        const next = game.floor + 1;
        if (next >= 100){
          enterFloor(100);
          enterWin();
        } else {
          enterFloor(next);
        }
      }
    }

    syncUI();
  }

  function render(){
    if (!game.running) return;

    const sx = (Math.random()*2-1) * (game.shake*10);
    const sy = (Math.random()*2-1) * (game.shake*6);

    ctx.save();
    ctx.translate(sx, sy);

    drawRoom();
    drawEvent();
    drawPlayer();

    // lighting overlay
    ctx.save();
    const dark = clamp(1 - game.lights, 0, 0.88);
    ctx.fillStyle = `rgba(0,0,0,${dark})`;
    ctx.fillRect(0,0,cv.width,cv.height);
    ctx.restore();

    vignette(0.30 + (1-game.lights)*0.45);

    // end banners
    if (game.state === "fail") drawBanner("OYUN BİTTİ", "Esc: Menü");
    if (game.state === "win") drawBanner("KAZANDIN", "100. kat");

    ctx.restore();
  }

  function drawBanner(title, sub){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "rgba(0,0,0,.62)";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;

    const bw = Math.min(760, Math.floor(W*0.80));
    const bh = Math.min(240, Math.floor(H*0.34));
    const x = (W-bw)/2, y=(H-bh)/2;

    ctx.fillStyle = "rgba(10,14,26,.88)";
    pxRect(x,y,bw,bh);
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.strokeRect(x,y,bw,bh);

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = `${Math.max(28, Math.floor(Math.min(W,H)/24))}px ui-monospace, Menlo, Consolas, monospace`;
    const tw = ctx.measureText(title).width;
    ctx.fillText(title, (W-tw)/2, y + Math.floor(bh*0.48));

    ctx.fillStyle = game.palette ? game.palette.neon : "rgba(106,215,255,.9)";
    ctx.font = `${Math.max(14, Math.floor(Math.min(W,H)/56))}px system-ui, Arial`;
    const sw = ctx.measureText(sub).width;
    ctx.fillText(sub, (W-sw)/2, y + Math.floor(bh*0.68));
    ctx.restore();
  }

  function loop(){
    const t = now();
    const dt = Math.min(33, t - last);
    last = t;

    pressed.clear();
    // pressed is filled on keydown; we clear at start so we need to capture it differently
    // Fix: store snapshot of pressed from last frame
    // We'll do a simple approach: keep pressedKeys array on keydown and clear after update.
    requestAnimationFrame(loop);
  }

  // Better input: keep pressedSet and clear after each frame
  function frame(){
    const t = now();
    const dt = Math.min(33, t - last);
    last = t;

    update(dt);
    render();

    // clear pressed after using
    pressed.clear();
    requestAnimationFrame(frame);
  }

  /* =========================
     Menu
  ========================= */
  const btnStart = document.getElementById("btnStart");
  const btnHow = document.getElementById("btnHow");
  const btnRestart = document.getElementById("btnRestart");
  const howPanel = document.getElementById("howPanel");

  btnHow.addEventListener("click", ()=>{
    howPanel.classList.toggle("hide");
  });

  btnRestart.addEventListener("click", ()=>{
    hardReset();
  });

  btnStart.addEventListener("click", ()=>{
    startGame();
  });

  function toggleMenu(){
    if (!game.running) return;
    const open = !menu.classList.contains("hide");
    if (open){
      menu.classList.add("hide");
      game.pausedMenu = false;
      showToast("Devam", 900);
    } else {
      menu.classList.remove("hide");
      game.pausedMenu = true;
      showToast("Menü", 900);
    }
  }

  function startGame(){
    menu.classList.add("hide");
    hud.classList.remove("hide");
    game.running = true;
    game.pausedMenu = false;
    game.t = 0;

    // initialize
    enterFloor(game.floor);
    showToast("Başladı. Amaç: 100. kat.", 1800);
  }

  function hardReset(){
    game.running = true; // keep rendering even if menu open
    game.floor = 1;
    game.state = "ready";
    game.t = 0;
    game.lights = 1;
    game.shake = 0;
    game.event = null;
    game.room = roomForFloor(1);
    game.palette = paletteForFloor(1);

    player.hp = 3;
    player.keys = 0;
    player.hidden = false;
    player.invuln = 0;
    player.face = 1;

    enterFloor(1);
    menu.classList.remove("hide");
    game.pausedMenu = true;
    showToast("Sıfırlandı.", 1200);
  }

  // Start in menu
  hud.classList.remove("hide");
  showToast("Menü: Başlat ile oyna.", 1600);

  // Main frame
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
