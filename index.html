<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>The Elevator</title>
<style>
  :root{
    --bg:#05060a;
    --fg:#eaf2ff;
    --muted:#a8b6c6;
    --glass: rgba(18,24,44,.72);
    --glass2: rgba(10,14,26,.82);
    --line: rgba(255,255,255,.10);
    --line2: rgba(255,255,255,.18);
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
  canvas{width:100vw; height:100vh; display:block; background:#02030a; image-rendering:pixelated; image-rendering:crisp-edges;}

  .hud{
    position:fixed; left:12px; top:12px; z-index:20;
    display:flex; gap:10px; flex-wrap:wrap;
    pointer-events:none; user-select:none;
  }
  .chip{
    background:var(--glass);
    border:1px solid var(--line);
    border-radius:999px;
    padding:8px 12px;
    font-size:13px;
    letter-spacing:.2px;
    backdrop-filter: blur(10px);
  }
  .chip b{font-weight:900}

  .toast{
    position:fixed; right:12px; top:12px; z-index:30;
    max-width:min(640px, calc(100vw - 24px));
    background:var(--glass2);
    border:1px solid var(--line);
    border-radius:14px;
    padding:10px 12px;
    font-size:13px;
    line-height:1.35;
    opacity:0;
    transform:translateY(-8px);
    transition:.16s ease;
    pointer-events:none; user-select:none;
    white-space:pre-line;
    backdrop-filter: blur(12px);
  }
  .toast.show{opacity:1; transform:translateY(0);}

  .menu{
    position:fixed; inset:0; z-index:50;
    display:flex; align-items:center; justify-content:center;
    background:
      radial-gradient(900px 700px at 20% 20%, rgba(106,215,255,.20), transparent 60%),
      radial-gradient(900px 700px at 85% 70%, rgba(255,79,123,.16), transparent 58%),
      radial-gradient(900px 700px at 40% 90%, rgba(255,227,123,.12), transparent 55%),
      linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.72));
  }
  .card{
    width:min(920px, calc(100vw - 24px));
    background:rgba(10,14,26,.86);
    border:1px solid rgba(255,255,255,.14);
    border-radius:18px;
    padding:16px;
    box-shadow:0 26px 90px rgba(0,0,0,.62);
    backdrop-filter: blur(12px);
  }
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
  .title{font-size:28px; font-weight:950; letter-spacing:.6px;}
  .sub{color:var(--muted); margin-top:6px; font-size:14px; line-height:1.45;}
  .grid{display:grid; grid-template-columns: 1.05fr .95fr; gap:12px; margin-top:12px;}
  @media (max-width:920px){.grid{grid-template-columns:1fr;}}
  .panel{
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.03);
    border-radius:16px;
    padding:14px;
  }
  .panel h3{margin:0 0 8px; font-size:14px; letter-spacing:.2px;}
  .panel p{margin:0; color:var(--muted); font-size:13px; line-height:1.5;}
  .kbd{
    display:inline-block;
    padding:2px 7px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.25);
    color:var(--fg);
    font-size:12px;
    margin:0 2px;
    font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  }
  .btns{display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;}
  button{
    appearance:none;
    border:1px solid rgba(255,255,255,.14);
    background:rgba(0,0,0,.25);
    color:var(--fg);
    padding:10px 12px;
    border-radius:14px;
    cursor:pointer;
    font-weight:900;
    font-size:13px;
    transition:.14s ease;
  }
  button:hover{transform:translateY(-1px); border-color: rgba(106,215,255,.38);}
  button:active{transform:translateY(0);}
  .danger{border-color: rgba(255,79,123,.34);}
  .danger:hover{border-color: rgba(255,79,123,.56);}
  .toggle{
    display:flex; align-items:center; justify-content:space-between;
    gap:10px; padding:10px 10px; border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.18);
    margin-top:10px;
  }
  input[type="range"]{width:180px;}
  .small{margin-top:10px; color:var(--muted); font-size:12px; line-height:1.5;}
  .hide{display:none!important;}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div class="hud" id="hud">
  <div class="chip">Kat: <b id="uiFloor">1</b>/100</div>
  <div class="chip">Can: <b id="uiHP">3</b></div>
  <div class="chip">Dayanıklılık: <b id="uiStam">100</b></div>
  <div class="chip">Pil: <b id="uiBat">100</b></div>
  <div class="chip">Envanter: <b id="uiInv">-</b></div>
  <div class="chip">Görev: <b id="uiGoal">-</b></div>
  <div class="chip">Tehdit: <b id="uiThreat">Yok</b></div>
</div>

<div class="toast" id="toast"></div>

<div class="menu" id="menu">
  <div class="card">
    <div class="row">
      <div>
        <div class="title">The Elevator</div>
        <div class="sub">
          Tam ekran 2D pikselli korku-kaçış. 100 kata kadar çık.
          Her kat farklı oda şablonu + farklı görev + görünür canavar.
        </div>
      </div>
      <div class="btns">
        <button id="btnContinue">Devam</button>
        <button id="btnNew">Yeni Oyun</button>
        <button id="btnHow">Kontroller</button>
        <button id="btnSettings">Ayarlar</button>
        <button id="btnWipe" class="danger">Kaydı Sil</button>
      </div>
    </div>

    <div class="grid">
      <div class="panel" id="howPanel" class="hide">
        <h3>Kontroller</h3>
        <p>
          Hareket: <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">←</span><span class="kbd">→</span><br>
          Sprint: <span class="kbd">Shift</span> (dayanıklılık harcar)<br>
          Etkileşim: <span class="kbd">W</span> / <span class="kbd">↑</span><br>
          Saklan (dolap): <span class="kbd">Space</span><br>
          Fener Aç/Kapat: <span class="kbd">F</span> (pil harcar)<br>
          Asansör: <span class="kbd">Enter</span><br>
          Menü: <span class="kbd">Esc</span>
        </p>
        <div class="small">
          Görev bitmeden asansör çalışmaz. Bazı katlar “karanlık” gelir, fener önemli olur.
        </div>
      </div>

      <div class="panel hide" id="settingsPanel">
        <h3>Ayarlar</h3>
        <div class="toggle">
          <div>Ses</div>
          <input id="rngVol" type="range" min="0" max="100" value="50"/>
        </div>
        <div class="toggle">
          <div>Zorluk</div>
          <input id="rngDiff" type="range" min="1" max="5" value="3"/>
        </div>
        <div class="toggle">
          <div>Shake</div>
          <input id="rngShake" type="range" min="0" max="100" value="65"/>
        </div>
        <div class="small">
          Zorluk artınca canavar hızı/algısı yükselir, pil daha hızlı biter.
        </div>
      </div>

      <div class="panel">
        <h3>Oyunun Fikri</h3>
        <p>
          Kapalı bir asansör döngüsünde her kat farklı tuzak.
          Kat görevleri: anahtar, sigorta onarımı, şifre, kol, terminal taraması, kısa “toplama” görevleri.
          Tehditler: dolaşan avcı, hızlı geçiş, bakış cezası, dalga geçişleri.
        </p>
        <div class="small">
          Bu sürüm “büyük oyun çekirdeği”. Devamında kat türlerini 2 katına çıkarıp canavar sprite’larını çeşitlendiririz.
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  "use strict";

  /* =========================
     Canvas / Resize
  ========================= */
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");
  function fitCanvas(){
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    cv.width = Math.floor(window.innerWidth * dpr);
    cv.height = Math.floor(window.innerHeight * dpr);
  }
  window.addEventListener("resize", fitCanvas);
  fitCanvas();

  /* =========================
     UI
  ========================= */
  const hud = document.getElementById("hud");
  const menu = document.getElementById("menu");
  const toast = document.getElementById("toast");

  const uiFloor = document.getElementById("uiFloor");
  const uiHP = document.getElementById("uiHP");
  const uiStam = document.getElementById("uiStam");
  const uiBat = document.getElementById("uiBat");
  const uiInv = document.getElementById("uiInv");
  const uiGoal = document.getElementById("uiGoal");
  const uiThreat = document.getElementById("uiThreat");

  const btnContinue = document.getElementById("btnContinue");
  const btnNew = document.getElementById("btnNew");
  const btnHow = document.getElementById("btnHow");
  const btnSettings = document.getElementById("btnSettings");
  const btnWipe = document.getElementById("btnWipe");
  const howPanel = document.getElementById("howPanel");
  const settingsPanel = document.getElementById("settingsPanel");

  const rngVol = document.getElementById("rngVol");
  const rngDiff = document.getElementById("rngDiff");
  const rngShake = document.getElementById("rngShake");

  let toastTimer = 0;
  function showToast(text, ms=2200){
    toast.textContent = text;
    toast.classList.add("show");
    toastTimer = ms;
  }

  /* =========================
     Helpers / RNG
  ========================= */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const rand=(a,b)=>a+Math.random()*(b-a);
  const randi=(a,b)=>Math.floor(rand(a,b+1));
  function now(){ return performance.now(); }

  function hashStr(s){
    let h=2166136261>>>0;
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h>>>0;
  }
  function seededRand(seed){
    let x = seed>>>0;
    return () => {
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    };
  }

  /* =========================
     Audio (WebAudio)
  ========================= */
  const AudioSys = (() => {
    let ac = null;
    let master = null;
    let vol = 0.5;

    function ensure(){
      if (ac) return;
      ac = new (window.AudioContext || window.webkitAudioContext)();
      master = ac.createGain();
      master.gain.value = vol;
      master.connect(ac.destination);
    }

    function setVol(v01){
      vol = clamp(v01,0,1);
      if (master) master.gain.value = vol;
    }

    function beep(freq=440, ms=90, type="square", gain=0.08){
      ensure();
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g);
      g.connect(master);

      const t0 = ac.currentTime;
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(gain, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + ms/1000);

      o.start(t0);
      o.stop(t0 + ms/1000 + 0.02);
    }

    function thump(){
      beep(78, 120, "sine", 0.12);
      beep(52, 140, "sine", 0.10);
    }

    function hiss(ms=260){
      ensure();
      const bufferSize = 2 * ac.sampleRate;
      const noiseBuffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1);

      const whiteNoise = ac.createBufferSource();
      whiteNoise.buffer = noiseBuffer;

      const g = ac.createGain();
      g.gain.value = 0.02;

      whiteNoise.connect(g);
      g.connect(master);

      whiteNoise.start();
      whiteNoise.stop(ac.currentTime + ms/1000);
    }

    return { setVol, beep, thump, hiss, ensure };
  })();

  /* =========================
     Input
  ========================= */
  const keys = new Set();
  const pressed = new Set();
  window.addEventListener("keydown",(e)=>{
    const k=(e.key||"").toLowerCase();
    if (!keys.has(k)) pressed.add(k);
    keys.add(k);

    if (["arrowleft","arrowright","arrowup"," ","spacebar"].includes(k) || e.key===" ") e.preventDefault();

    // ensure audio starts after user gesture
    AudioSys.ensure();
  }, {passive:false});
  window.addEventListener("keyup",(e)=>keys.delete((e.key||"").toLowerCase()));
  const isDown=(k)=>keys.has(k);
  const wasPressed=(k)=>pressed.has(k);

  /* =========================
     Names / Palettes / Themes
  ========================= */
  const nameA=["Noct","Vanta","Ruin","Gloom","Sable","Grim","Dread","Murk","Void","Shade","Crypt","Cinder","Hollow","Wraith","Ash","Frost","Abyss","Veil"];
  const nameB=["Runner","Seer","Stalker","Crawler","Drifter","Whisper","Warden","Echo","Binder","Harrier","Mangler","Sunder","Lurker","Watcher","Strider","Snare","Hound","Taker"];
  const nameC=["I","II","III","IV","V","VI","VII","VIII","IX","X","XI","XII"];
  function monsterNameForFloor(floor){
    const rnd = seededRand(hashStr("MonsterName:"+floor));
    return `${nameA[Math.floor(rnd()*nameA.length)]} ${nameB[Math.floor(rnd()*nameB.length)]} ${nameC[Math.floor(rnd()*nameC.length)]}`;
  }

  function paletteForFloor(floor, theme){
    const rnd = seededRand(hashStr("Pal:"+floor+":"+theme));
    const hues = [195,320,42,265,155,10,230,285,90,340,180,210];
    const baseHue = hues[Math.floor(rnd()*hues.length)];
    const accentHue = (baseHue + 60 + Math.floor(rnd()*90)) % 360;
    const sat1 = 70 + Math.floor(rnd()*22);
    const sat2 = 70 + Math.floor(rnd()*25);
    const bg1 = `hsl(${baseHue} ${sat1}% ${10 + Math.floor(rnd()*6)}%)`;
    const bg2 = `hsl(${(baseHue+22)%360} ${sat1}% ${6 + Math.floor(rnd()*5)}%)`;
    const wall = `hsl(${(baseHue+8)%360} ${sat1}% ${14 + Math.floor(rnd()*6)}%)`;
    const panel = `hsl(${(baseHue+14)%360} ${sat1}% ${18 + Math.floor(rnd()*6)}%)`;
    const neon = `hsl(${accentHue} ${sat2}% ${62 + Math.floor(rnd()*12)}%)`;
    const warn = `hsl(${(accentHue+170)%360} ${88}% ${60}%)`;
    const good = `hsl(${(accentHue+40)%360} ${80}% ${62}%)`;
    return {bg1,bg2,wall,panel,neon,warn,good};
  }

  const Themes = {
    LOBBY:"lobby",
    MAINT:"maint",
    HOSP:"hosp",
    OFFICE:"office",
    DARK:"dark",
    RED:"red"
  };

  function themeForFloor(floor){
    const rnd = seededRand(hashStr("Theme:"+floor));
    if (floor === 1) return Themes.LOBBY;
    if (floor % 15 === 0) return Themes.RED;
    if (floor % 9 === 0) return Themes.DARK;
    const r = rnd();
    if (r < 0.25) return Themes.OFFICE;
    if (r < 0.50) return Themes.MAINT;
    if (r < 0.75) return Themes.HOSP;
    return Themes.OFFICE;
  }

  /* =========================
     Room templates (vary layout)
  ========================= */
  function roomForFloor(floor, theme){
    const rnd = seededRand(hashStr("Room:"+floor+":"+theme));
    const W=cv.width, H=cv.height;

    const floorY = Math.floor(H*(0.80 + (rnd()*0.03 - 0.015)));

    const minRatio = 0.58, maxRatio = 0.90;
    const ratio = minRatio + (maxRatio-minRatio)*(0.18 + 0.82*rnd());
    const roomW = Math.floor(W*ratio);
    const leftWall = Math.floor((W-roomW)/2);
    const rightWall = leftWall + roomW;

    const elevW = Math.floor(140 + rnd()*150);
    const elevH = Math.floor(H*(0.30 + rnd()*0.12));
    const elevX = Math.floor(rightWall - elevW - (40 + rnd()*70));
    const elevY = Math.floor(floorY - elevH - (35 + rnd()*55));

    const lockerW = Math.floor(66 + rnd()*56);
    const lockerH = Math.floor(H*(0.17 + rnd()*0.10));
    const lockerX = Math.floor(leftWall + (40 + rnd()*130));
    const lockerY = Math.floor(floorY - lockerH);

    // spawn points
    const deskW = Math.floor(130 + rnd()*200);
    const deskH = Math.floor(48 + rnd()*70);
    const deskX = Math.floor(leftWall + roomW*(0.30 + rnd()*0.30));
    const deskY = Math.floor(floorY - deskH);

    // panel, keypad, lever
    const panelW = Math.floor(120 + rnd()*120);
    const panelH = Math.floor(60 + rnd()*60);
    const panelX = Math.floor(leftWall + roomW*(0.16 + rnd()*0.26));
    const panelY = Math.floor(floorY - panelH - (35 + rnd()*70));

    const keypadW=60, keypadH=80;
    const keypadX = Math.floor(elevX - (80 + rnd()*110));
    const keypadY = Math.floor(elevY + (40 + rnd()*90));

    const leverW=52, leverH=88;
    const leverX = Math.floor(leftWall + roomW*(0.60 + rnd()*0.28));
    const leverY = Math.floor(floorY - leverH - (30 + rnd()*60));

    // note/terminal positions
    const noteX = Math.floor(leftWall + 60 + rnd()*(roomW-140));
    const noteY = Math.floor(floorY - 240 - rnd()*180);

    const termW=140, termH=80;
    const termX = Math.floor(leftWall + roomW*(0.40 + rnd()*0.18));
    const termY = Math.floor(floorY - termH - (50 + rnd()*70));

    // props density
    const props = [];
    const propCount = 6 + Math.floor(rnd()*10);
    for (let i=0;i<propCount;i++){
      const px = Math.floor(leftWall + 40 + rnd()*(roomW-80));
      const py = Math.floor(floorY - (40 + rnd()*220));
      const pw = 18 + Math.floor(rnd()*80);
      const ph = 14 + Math.floor(rnd()*60);
      const kindRoll = rnd();
      let kind = "crate";
      if (kindRoll < 0.33) kind = "crate";
      else if (kindRoll < 0.66) kind = "pipe";
      else kind = "poster";
      props.push({x:px,y:py,w:pw,h:ph,kind});
    }

    return {
      W,H,floorY,leftWall,rightWall,
      elevX,elevY,elevW,elevH,
      doorW: Math.floor(elevW*0.42),
      doorH: Math.floor(elevH*0.62),
      lockerX,lockerY,lockerW,lockerH,
      deskX,deskY,deskW,deskH,
      panelX,panelY,panelW,panelH,
      keypadX,keypadY,keypadW,keypadH,
      leverX,leverY,leverW,leverH,
      noteX,noteY,
      termX,termY,termW,termH,
      props
    };
  }

  /* =========================
     Goals
  ========================= */
  const GoalType={
    NONE:"none",
    FIND_KEY:"find_key",
    FIX_FUSE:"fix_fuse",
    KEYPAD_CODE:"keypad_code",
    PULL_LEVER:"pull_lever",
    SCAN_TERMINAL:"scan_terminal",
    COLLECT_ORBS:"collect_orbs"
  };

  function makeCodeForFloor(floor){
    const rnd = seededRand(hashStr("Code:"+floor));
    const d1 = 1 + Math.floor(rnd()*9);
    const d2 = Math.floor(rnd()*10);
    const d3 = Math.floor(rnd()*10);
    return ""+d1+d2+d3;
  }

  function goalForFloor(floor, theme){
    const rnd = seededRand(hashStr("Goal:"+floor+":"+theme));
    if (floor===1) return {type:GoalType.NONE, text:"Serbest", done:true};

    // special “lock floors”
    if (floor % 10 === 0){
      return (rnd()<0.5)
        ? {type:GoalType.KEYPAD_CODE, text:"Şifre bul", done:false}
        : {type:GoalType.FIND_KEY, text:"Anahtar bul", done:false};
    }

    // theme influences goals
    if (theme === Themes.MAINT){
      if (rnd() < 0.55) return {type:GoalType.FIX_FUSE, text:"Sigorta onar", done:false};
      return {type:GoalType.PULL_LEVER, text:"Kolu çek", done:false};
    }
    if (theme === Themes.HOSP){
      if (rnd() < 0.55) return {type:GoalType.SCAN_TERMINAL, text:"Terminal taraması", done:false};
      return {type:GoalType.COLLECT_ORBS, text:"3 iz topla", done:false, need:3, got:0};
    }
    if (theme === Themes.DARK){
      if (rnd() < 0.45) return {type:GoalType.COLLECT_ORBS, text:"3 iz topla", done:false, need:3, got:0};
      return {type:GoalType.KEYPAD_CODE, text:"Şifre bul", done:false};
    }
    if (theme === Themes.RED){
      if (rnd() < 0.50) return {type:GoalType.FIX_FUSE, text:"Acil paneli onar", done:false};
      return {type:GoalType.SCAN_TERMINAL, text:"Alarmı sustur", done:false};
    }
    // office/lobby
    const r = rnd();
    if (r < 0.28) return {type:GoalType.FIND_KEY, text:"Anahtar bul", done:false};
    if (r < 0.52) return {type:GoalType.PULL_LEVER, text:"Kolu çek", done:false};
    if (r < 0.76) return {type:GoalType.KEYPAD_CODE, text:"Şifre bul", done:false};
    return {type:GoalType.SCAN_TERMINAL, text:"Terminal taraması", done:false};
  }

  /* =========================
     Monsters (visible)
  ========================= */
  const MonsterType={
    NONE:"none",
    ROAMER:"roamer",   // patrol/hunt
    PASSER:"passer",   // fast pass
    LOOKER:"looker",   // movement punish
    WAVES:"waves"      // multiple passes
  };

  function monsterForFloor(floor, theme, diff){
    const rnd = seededRand(hashStr("Mon:"+floor+":"+theme));
    const name = monsterNameForFloor(floor);
    const t = clamp((floor-1)/99,0,1);
    const have = rnd() < (0.55 + 0.30*t);
    if (!have) return {type:MonsterType.NONE, name};

    // weights
    const wR = 0.30 + 0.14*t;
    const wP = 0.30 + 0.10*t;
    const wL = 0.18;
    const wW = 0.22 + 0.16*t;
    const sum = wR+wP+wL+wW;
    let r = rnd()*sum;
    let type=MonsterType.ROAMER;
    if ((r-=wR)<0) type=MonsterType.ROAMER;
    else if ((r-=wP)<0) type=MonsterType.PASSER;
    else if ((r-=wL)<0) type=MonsterType.LOOKER;
    else type=MonsterType.WAVES;

    const base = 170 + floor*1.6 + diff*18;
    const big = 1 + t*0.35;

    if (type===MonsterType.ROAMER){
      return {
        type,name,
        x:0,y:0,w:46*big,h:42*big,
        vx: (rnd()<0.5?-1:1) * (base*0.75),
        agg: 0.22 + diff*0.06, // detection chance
        state:"patrol",
        cooldown: 0,
        help:"Odada dolaşıyor. Çarpışma hasar. Saklan (Space)."
      };
    }
    if (type===MonsterType.PASSER){
      return {
        type,name,
        x:-500,y:0,w:88*big,h:56*big,
        speed: base*3.6,
        phase:"warn",
        tt:0,
        help:"Geçiş geliyor. Dolaba gir (Space)."
      };
    }
    if (type===MonsterType.LOOKER){
      return {
        type,name,
        tt:0,
        duration: 2400 + Math.floor(rnd()*2800),
        help:"Hareket etme. Sprint kesin yasak."
      };
    }
    return {
      type,name,
      phase:"warn",
      tt:0,
      passes: 2 + Math.floor(rnd()*3) + (diff>=4?1:0),
      passIndex:0,
      dir: 1,
      x:-600,y:0,w:96*big,h:60*big,
      speed: base*3.1,
      help:"Dalga: geçişte saklan, arada çık."
    };
  }

  function rectsOverlap(a,b){
    return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h);
  }

  /* =========================
     Game state / Save
  ========================= */
  const SAVE_KEY="the_elevator_save_v2";

  const Settings = {
    vol: 0.50,
    diff: 3,
    shake: 0.65
  };

  function loadSettings(){
    try{
      const raw = localStorage.getItem(SAVE_KEY+"_settings");
      if (!raw) return;
      const s = JSON.parse(raw);
      if (typeof s.vol==="number") Settings.vol=clamp(s.vol,0,1);
      if (typeof s.diff==="number") Settings.diff=clamp(Math.round(s.diff),1,5);
      if (typeof s.shake==="number") Settings.shake=clamp(s.shake,0,1);
    }catch{}
  }
  function saveSettings(){
    localStorage.setItem(SAVE_KEY+"_settings", JSON.stringify(Settings));
  }

  function loadSave(){
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return null;
      const s = JSON.parse(raw);
      if (!s || typeof s.floor!=="number") return null;
      return s;
    }catch{return null;}
  }
  function saveGame(){
    const s = {
      floor: game.floor,
      hp: player.hp,
      keys: player.keys,
      bat: player.battery,
      theme: game.theme,
      diff: Settings.diff
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(s));
  }
  function wipeSave(){
    localStorage.removeItem(SAVE_KEY);
  }

  /* =========================
     Core State
  ========================= */
  const game = {
    running:false,
    state:"menu", // menu, play, moving, fail, win
    t:0,
    floor:1,
    theme: Themes.LOBBY,
    pal:null,
    room:null,
    goal:null,
    monster:null,
    lights:1,
    shake:0,
    // items/objects
    obj:{
      drawerUsed:false,
      noteTaken:false,
      code:null,
      fuseTaken:false,
      panelFixed:false,
      leverPulled:false,
      termDone:false,
      orbs:[],
      orbsGot:0
    },
    inv:{
      fuse:false,
      noteCode:null
    }
  };

  const player = {
    x:0,y:0,
    vx:0,
    w:22,h:46,
    hp:3,
    keys:0,
    stamina:100,
    battery:100,
    hidden:false,
    flashlight:false,
    face:1,
    invuln:0
  };

  function resetPerFloor(){
    game.obj.drawerUsed=false;
    game.obj.noteTaken=false;
    game.obj.code = makeCodeForFloor(game.floor);
    game.obj.fuseTaken=false;
    game.obj.panelFixed=false;
    game.obj.leverPulled=false;
    game.obj.termDone=false;
    game.obj.orbs=[];
    game.obj.orbsGot=0;

    game.inv.fuse=false;
    game.inv.noteCode=null;
  }

  function spawnOrbs(){
    const rnd = seededRand(hashStr("Orbs:"+game.floor+":"+game.theme));
    const R = game.room;
    const count = 3;
    for(let i=0;i<count;i++){
      const x = Math.floor(R.leftWall + 80 + rnd()*(R.rightWall-R.leftWall-160));
      const y = Math.floor(R.floorY - 120 - rnd()*220);
      game.obj.orbs.push({x,y,r:14, taken:false});
    }
  }

  /* =========================
     Pixel draw helpers
  ========================= */
  function pxRect(x,y,w,h){ ctx.fillRect(x|0,y|0,w|0,h|0); }

  function vignette(intensity){
    const W=cv.width,H=cv.height;
    ctx.save();
    const g = ctx.createRadialGradient(W/2,H/2,50,W/2,H/2,Math.max(W,H)*0.62);
    g.addColorStop(0,"rgba(0,0,0,0)");
    g.addColorStop(1,`rgba(0,0,0,${clamp(intensity,0,0.92)})`);
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);
    ctx.restore();
  }

  function drawTextBox(text,x,y,color){
    ctx.save();
    ctx.font = `${Math.max(14, Math.floor(Math.min(cv.width, cv.height)/68))}px ui-monospace, Menlo, Consolas, monospace`;
    const w = ctx.measureText(text).width;
    ctx.globalAlpha=0.92;
    ctx.fillStyle="rgba(0,0,0,.35)";
    pxRect(x-10,y-22,w+20,30);
    ctx.fillStyle=color||"rgba(255,255,255,.92)";
    ctx.fillText(text,x,y);
    ctx.restore();
  }

  function drawWarningStripes(alpha){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.globalAlpha=alpha;
    ctx.fillStyle=game.pal.warn;
    for(let i=-240;i<W+240;i+=42){
      ctx.beginPath();
      ctx.moveTo(i,0);
      ctx.lineTo(i+20,0);
      ctx.lineTo(i+260,H);
      ctx.lineTo(i+240,H);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }

  function drawPlayer(){
    if (player.hidden) return;
    const s = Math.max(2, Math.floor(Math.min(cv.width, cv.height)/360));
    const x=player.x, y=player.y;
    const ox=(x-6*s)|0, oy=(y-16*s)|0;

    ctx.globalAlpha=0.25;
    ctx.fillStyle="#000";
    pxRect(x-12*s, y-2*s, 24*s, 4*s);
    ctx.globalAlpha=1;

    const skin="#4b2f25";
    const shirt="#3d7bff";
    const pants="#1c2238";

    if (player.invuln>0 && Math.floor(player.invuln/80)%2===0) ctx.globalAlpha=0.45;

    ctx.fillStyle=pants;
    pxRect(ox+4*s, oy+12*s, 3*s, 4*s);
    pxRect(ox+9*s, oy+12*s, 3*s, 4*s);

    ctx.fillStyle="#090b14";
    pxRect(ox+3*s, oy+15*s, 4*s, 2*s);
    pxRect(ox+9*s, oy+15*s, 4*s, 2*s);

    ctx.fillStyle=shirt;
    pxRect(ox+4*s, oy+7*s, 8*s, 6*s);

    ctx.fillStyle=shirt;
    pxRect(ox+2*s, oy+8*s, 2*s, 4*s);
    pxRect(ox+12*s, oy+8*s, 2*s, 4*s);

    ctx.fillStyle=skin;
    pxRect(ox+2*s, oy+11*s, 2*s, 2*s);
    pxRect(ox+12*s, oy+11*s, 2*s, 2*s);

    ctx.fillStyle=skin;
    pxRect(ox+5*s, oy+2*s, 6*s, 5*s);

    ctx.fillStyle="#141018";
    pxRect(ox+5*s, oy+2*s, 6*s, 2*s);

    ctx.fillStyle="#eaf2ff";
    pxRect(ox+6*s, oy+4*s, 1*s, 1*s);
    pxRect(ox+9*s, oy+4*s, 1*s, 1*s);

    ctx.fillStyle="#0a0c12";
    const dir = player.face>0 ? 1 : 0;
    pxRect(ox+(6+dir)*s, oy+4*s, 1*s, 1*s);
    pxRect(ox+(9+dir)*s, oy+4*s, 1*s, 1*s);

    ctx.fillStyle="#0a0c12";
    pxRect(ox+7*s, oy+6*s, 2*s, 1*s);

    ctx.globalAlpha=1;
  }

  function drawMonster(m){
    const P=game.pal;
    if (!m || m.type===MonsterType.NONE) return;

    if (m.type===MonsterType.LOOKER){
      const W=cv.width,H=cv.height;
      const x=W/2, y=Math.floor(H*0.22);
      ctx.save();
      ctx.globalAlpha=0.92;
      ctx.fillStyle="rgba(255,255,255,.84)";
      pxRect(x-95,y-18,72,28);
      pxRect(x+23,y-18,72,28);
      ctx.fillStyle="rgba(0,0,0,.86)";
      const p = player.face>0 ? 12 : -12;
      pxRect(x-64+p,y-10,18,18);
      pxRect(x+52+p,y-10,18,18);
      ctx.restore();
      drawTextBox(m.name, Math.floor(x-160), Math.floor(H*0.12), P.warn);
      return;
    }

    // blob sprite
    ctx.save();
    ctx.globalAlpha=0.92;
    ctx.fillStyle=P.warn;
    const step = Math.max(14, Math.floor(Math.min(cv.width, cv.height)/64));
    const cx=m.x, cy=m.y, w=m.w, h=m.h;
    for(let yy=-h/2; yy<=h/2; yy+=step){
      for(let xx=-w/2; xx<=w/2; xx+=step){
        const d=(xx*xx)/(w*w)+(yy*yy)/(h*h);
        if (d < 0.24 + Math.random()*0.26) pxRect(cx+xx, cy+yy, step-2, step-2);
      }
    }
    // eyes
    const s = Math.max(2, Math.floor(Math.min(cv.width, cv.height)/420));
    ctx.fillStyle="rgba(255,255,255,.86)";
    pxRect(cx+18*s, cy-10*s, 12*s, 7*s);
    pxRect(cx+44*s, cy-10*s, 12*s, 7*s);
    ctx.fillStyle="rgba(0,0,0,.90)";
    pxRect(cx+22*s, cy-8*s, 5*s, 5*s);
    pxRect(cx+48*s, cy-8*s, 5*s, 5*s);
    ctx.restore();

    drawTextBox(m.name, clamp(cx-160, 18, cv.width-320), clamp(cy-m.h/2-18, 30, cv.height-30), P.warn);
  }

  function drawProps(){
    const P=game.pal;
    const R=game.room;
    for(const pr of R.props){
      if (pr.kind==="poster"){
        ctx.globalAlpha=0.85;
        ctx.fillStyle="rgba(255,255,255,.10)";
        pxRect(pr.x, pr.y, pr.w, pr.h);
        ctx.globalAlpha=1;
      } else if (pr.kind==="pipe"){
        ctx.globalAlpha=0.85;
        ctx.fillStyle="rgba(0,0,0,.28)";
        pxRect(pr.x, pr.y, pr.w, Math.max(6, Math.floor(pr.h*0.25)));
        ctx.globalAlpha=1;
      } else {
        ctx.globalAlpha=0.90;
        ctx.fillStyle="rgba(0,0,0,.30)";
        pxRect(pr.x, pr.y, pr.w, pr.h);
        ctx.fillStyle="rgba(255,255,255,.08)";
        pxRect(pr.x+4, pr.y+4, pr.w-8, pr.h-8);
        ctx.globalAlpha=1;
      }
    }

    // orbs for collect goal
    if (game.goal && game.goal.type===GoalType.COLLECT_ORBS){
      for(const o of game.obj.orbs){
        if (o.taken) continue;
        ctx.globalAlpha=0.90;
        ctx.fillStyle=game.pal.neon;
        pxRect(o.x-6, o.y-6, 12, 12);
        ctx.globalAlpha=0.35;
        ctx.fillStyle=game.pal.neon;
        pxRect(o.x-16, o.y-16, 32, 32);
        ctx.globalAlpha=1;
      }
    }
  }

  function drawRoom(){
    const R=game.room, P=game.pal;
    const W=cv.width, H=cv.height;

    // background
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,P.bg1);
    g.addColorStop(1,P.bg2);
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);

    // grid
    const step=Math.max(22, Math.floor(Math.min(W,H)/32));
    ctx.globalAlpha=0.10;
    ctx.fillStyle=P.neon;
    for(let y=0;y<H;y+=step) pxRect(0,y,W,1);
    for(let x=0;x<W;x+=step) pxRect(x,0,1,H);
    ctx.globalAlpha=1;

    // walls/floor
    const topY=Math.floor(H*0.10);
    ctx.fillStyle=P.wall;
    pxRect(R.leftWall, topY, R.rightWall-R.leftWall, R.floorY-topY);
    ctx.fillStyle=P.panel;
    pxRect(0, R.floorY, W, H-R.floorY);
    ctx.fillStyle="rgba(255,255,255,.12)";
    pxRect(R.leftWall, R.floorY, R.rightWall-R.leftWall, 2);

    // theme overlays
    if (game.theme===Themes.HOSP){
      ctx.globalAlpha=0.10;
      ctx.fillStyle="rgba(255,255,255,.9)";
      for(let i=0;i<8;i++){
        const x = R.leftWall + 60 + i*90;
        pxRect(x, topY+30, 50, 10);
      }
      ctx.globalAlpha=1;
    }
    if (game.theme===Themes.MAINT){
      ctx.globalAlpha=0.12;
      ctx.fillStyle="rgba(0,0,0,.9)";
      for(let i=0;i<10;i++){
        const x = R.leftWall + 40 + i*70;
        pxRect(x, topY+40, 30, 4);
      }
      ctx.globalAlpha=1;
    }
    if (game.theme===Themes.RED){
      ctx.globalAlpha=0.12;
      ctx.fillStyle=P.warn;
      pxRect(R.leftWall, topY, R.rightWall-R.leftWall, 8);
      ctx.globalAlpha=1;
    }

    // props
    drawProps();

    // elevator
    ctx.fillStyle="rgba(0,0,0,.35)";
    pxRect(R.elevX, R.elevY, R.elevW, R.elevH);
    ctx.fillStyle="rgba(255,255,255,.08)";
    pxRect(R.elevX+8, R.elevY+8, R.elevW-16, R.elevH-16);

    const open = (game.state==="moving") ? clamp(game.t/650,0,1) : 0;
    const gap = Math.floor(40*open);
    ctx.fillStyle="rgba(255,255,255,.10)";
    pxRect(R.elevX + 14 - gap, R.elevY + Math.floor(R.elevH*0.22), R.doorW, R.doorH);
    pxRect(R.elevX + R.elevW - 14 - R.doorW + gap, R.elevY + Math.floor(R.elevH*0.22), R.doorW, R.doorH);

    // elevator panel light indicates locked/unlocked
    ctx.fillStyle = (game.goal && game.goal.done) ? P.good : P.neon;
    pxRect(R.elevX + R.elevW - 30, R.elevY + 18, 14, 14);

    // locker
    ctx.fillStyle="rgba(0,0,0,.35)";
    pxRect(R.lockerX, R.lockerY, R.lockerW, R.lockerH);
    ctx.fillStyle="rgba(255,255,255,.08)";
    pxRect(R.lockerX+6, R.lockerY+6, R.lockerW-12, R.lockerH-12);
    ctx.fillStyle="rgba(104,255,177,.85)";
    pxRect(R.lockerX+R.lockerW-14, R.lockerY+Math.floor(R.lockerH/2), 6, 6);

    // desk
    ctx.fillStyle="rgba(0,0,0,.35)";
    pxRect(R.deskX, R.deskY, R.deskW, R.deskH);
    ctx.fillStyle="rgba(255,255,255,.08)";
    pxRect(R.deskX+6, R.deskY+6, R.deskW-12, R.deskH-12);
    ctx.fillStyle = game.obj.drawerUsed ? "rgba(255,255,255,.25)" : "rgba(255,227,123,.85)";
    pxRect(R.deskX + R.deskW - 18, R.deskY + Math.floor(R.deskH/2), 10, 4);

    // panel
    ctx.fillStyle="rgba(0,0,0,.30)";
    pxRect(R.panelX, R.panelY, R.panelW, R.panelH);
    ctx.fillStyle="rgba(255,255,255,.08)";
    pxRect(R.panelX+6, R.panelY+6, R.panelW-12, R.panelH-12);
    ctx.fillStyle = game.obj.panelFixed ? P.good : P.warn;
    pxRect(R.panelX + R.panelW - 18, R.panelY + 14, 10, 10);

    // keypad
    ctx.fillStyle="rgba(0,0,0,.30)";
    pxRect(R.keypadX, R.keypadY, R.keypadW, R.keypadH);
    ctx.fillStyle="rgba(255,255,255,.10)";
    pxRect(R.keypadX+6, R.keypadY+6, R.keypadW-12, R.keypadH-12);
    ctx.fillStyle = game.obj.noteTaken ? P.neon : "rgba(255,255,255,.18)";
    pxRect(R.keypadX + 16, R.keypadY + 12, 28, 8);

    // lever
    ctx.fillStyle="rgba(0,0,0,.30)";
    pxRect(R.leverX, R.leverY, R.leverW, R.leverH);
    ctx.fillStyle = game.obj.leverPulled ? P.good : P.neon;
    pxRect(R.leverX + 20, R.leverY + 12, 12, 58);

    // terminal
    ctx.fillStyle="rgba(0,0,0,.30)";
    pxRect(R.termX, R.termY, R.termW, R.termH);
    ctx.fillStyle="rgba(255,255,255,.10)";
    pxRect(R.termX+6, R.termY+6, R.termW-12, R.termH-12);
    ctx.fillStyle = game.obj.termDone ? P.good : P.neon;
    pxRect(R.termX + 14, R.termY + 14, R.termW-28, 10);

    // note (clue)
    ctx.fillStyle = game.obj.noteTaken ? "rgba(255,255,255,.18)" : "rgba(255,255,255,.62)";
    pxRect(R.noteX, R.noteY, 34, 22);

    // labels
    ctx.globalAlpha=0.78;
    ctx.fillStyle=P.neon;
    ctx.font=`${Math.max(12, Math.floor(Math.min(W,H)/78))}px system-ui, Arial`;
    ctx.fillText("Dolap (Space)", R.lockerX-2, R.lockerY-10);
    ctx.fillText("Eşya (W)", R.deskX, R.deskY-10);
    ctx.fillText("Panel (W)", R.panelX, R.panelY-10);
    ctx.fillText("Şifre (W)", R.keypadX-10, R.keypadY-10);
    ctx.fillText("Kol (W)", R.leverX-10, R.leverY-10);
    ctx.fillText("Terminal (W)", R.termX-10, R.termY-10);
    ctx.fillText("Asansör (Enter)", R.elevX+10, R.elevY+R.elevH+18);
    ctx.globalAlpha=1;

    // sign
    ctx.globalAlpha=0.85;
    ctx.fillStyle="rgba(0,0,0,.25)";
    pxRect(R.leftWall+36, topY, 320, 30);
    ctx.fillStyle="rgba(255,255,255,.85)";
    ctx.font=`${Math.max(14, Math.floor(Math.min(W,H)/60))}px ui-monospace, Menlo, Consolas, monospace`;
    ctx.fillText(`FLOOR ${game.floor}  THEME ${game.theme.toUpperCase()}`, R.leftWall+50, topY+22);
    ctx.globalAlpha=1;

    // hide overlay
    if (player.hidden){
      ctx.globalAlpha=0.55;
      ctx.fillStyle="rgba(0,0,0,.78)";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=1;
      drawTextBox("Dolaptasın. Sessiz kal.", 24, 44, P.neon);
    }
  }

  /* =========================
     Flashlight + darkness
  ========================= */
  function applyFlashlight(){
    // only meaningful in DARK theme (and sometimes others)
    const isDark = (game.theme === Themes.DARK);
    if (!isDark) return;

    const W=cv.width,H=cv.height;
    ctx.save();
    // base darkness
    ctx.globalAlpha=0.72;
    ctx.fillStyle="rgba(0,0,0,.80)";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha=1;

    if (player.flashlight && player.battery>0 && !player.hidden){
      const x=player.x, y=player.y-player.h*0.65;
      const r1=Math.max(120, Math.min(W,H)*0.18);
      const r2=Math.max(280, Math.min(W,H)*0.42);
      const g=ctx.createRadialGradient(x,y,r1, x,y,r2);
      g.addColorStop(0,"rgba(0,0,0,0)");
      g.addColorStop(1,"rgba(0,0,0,.90)");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,W,H);
    } else {
      // almost blind
      ctx.globalAlpha=0.22;
      ctx.fillStyle="rgba(255,255,255,.02)";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha=1;
    }
    ctx.restore();
  }

  /* =========================
     Monster update
  ========================= */
  function initMonsterPos(){
    const R=game.room;
    const m=game.monster;
    if (!m || m.type===MonsterType.NONE) return;
    const midY = Math.floor(R.floorY - 140);
    if (m.type===MonsterType.ROAMER){
      const rnd=seededRand(hashStr("RoamPos:"+game.floor+":"+game.theme));
      m.x = Math.floor(lerp(R.leftWall+100, R.rightWall-100, rnd()));
      m.y = midY + Math.floor((rnd()*2-1)*40);
    } else if (m.type===MonsterType.PASSER){
      m.x=-600; m.y=midY+40;
    } else if (m.type===MonsterType.WAVES){
      m.x=-650; m.y=midY+40;
    }
  }

  function updateMonster(dt){
    const m=game.monster;
    if (!m || m.type===MonsterType.NONE) return;

    const R=game.room;
    const W=cv.width;
    const diff=Settings.diff;

    if (m.type===MonsterType.LOOKER){
      m.tt += dt;
      game.lights = lerp(game.lights, 0.72, 0.05);

      const moving = Math.abs(player.vx) > 1;
      if (moving) damage(m.name + " hareketini fark etti.");

      if (m.tt > m.duration){
        game.monster = {type:MonsterType.NONE, name:"-"};
        uiThreat.textContent="Yok";
        showToast("Tehdit geçti.", 1400);
      }
      return;
    }

    const pbox = {x:player.x-12, y:player.y-player.h, w:24, h:player.h};

    if (m.type===MonsterType.PASSER){
      m.tt += dt;
      if (m.phase==="warn"){
        game.lights = lerp(game.lights, 0.72, 0.04);
        if (m.tt > 900){
          m.phase="pass"; m.tt=0;
          m.x=-700;
          game.shake=0.35;
          AudioSys.hiss(200);
          showToast("Geçiş: " + m.name, 1500);
        }
      } else {
        game.lights = lerp(game.lights, 0.58, 0.06);
        m.x += m.speed * (dt/1000);
        game.shake = lerp(game.shake, 0.85, 0.06);

        const hit={x:m.x-m.w/2, y:m.y-m.h/2, w:m.w, h:m.h};
        if (rectsOverlap(hit,pbox) && !player.hidden) damage(m.name + " yakaladı.");

        if (m.x > W + 750){
          game.monster = {type:MonsterType.NONE, name:"-"};
          uiThreat.textContent="Yok";
          showToast("Geçiş bitti.", 1200);
          game.lights = 1;
          game.shake = 0;
        }
      }
      return;
    }

    if (m.type===MonsterType.WAVES){
      m.tt += dt;
      if (m.phase==="warn"){
        game.lights = lerp(game.lights, 0.70, 0.05);
        if (m.tt > 900){
          m.phase="pass"; m.tt=0;
          m.x = (m.dir>0) ? -750 : (W+750);
          game.shake=0.45;
          AudioSys.hiss(220);
          showToast("Dalga: " + m.name, 1600);
        }
      } else if (m.phase==="pass"){
        game.lights = lerp(game.lights, 0.55, 0.06);
        m.x += m.dir * m.speed * (dt/1000);
        game.shake = lerp(game.shake, 0.85, 0.06);

        const hit={x:m.x-m.w/2, y:m.y-m.h/2, w:m.w, h:m.h};
        if (rectsOverlap(hit,pbox) && !player.hidden) damage(m.name + " yakaladı.");

        const outR = m.x > W+800;
        const outL = m.x < -800;
        if (outR || outL){
          m.phase="quiet"; m.tt=0;
          m.dir *= -1;
          m.passIndex += 1;
          game.shake=0.10;
          game.lights=0.82;
          showToast("Sessizlik.", 950);
        }
      } else {
        game.lights = lerp(game.lights, 0.88, 0.05);
        if (player.hidden && Math.random() < (0.0015 + diff*0.0006) * (dt/16)) damage(m.name + " sabırsızlandı.");

        if (m.tt > 850){
          if (m.passIndex >= m.passes){
            game.monster = {type:MonsterType.NONE, name:"-"};
            uiThreat.textContent="Yok";
            showToast("Dalga bitti.", 1200);
            game.lights=1; game.shake=0;
          } else {
            m.phase="pass"; m.tt=0;
            m.x = (m.dir>0) ? -750 : (W+750);
            game.shake=0.5;
          }
        }
      }
      return;
    }

    // ROAMER: patrol + occasionally "rush" toward player unless hidden
    if (m.type===MonsterType.ROAMER){
      const minX=R.leftWall+90;
      const maxX=R.rightWall-90;

      m.cooldown = Math.max(0, m.cooldown - dt);

      // detect chance (harder difficulty -> higher)
      const dist = Math.abs(player.x - m.x);
      const sees = !player.hidden && dist < (220 + Settings.diff*40);
      const willChase = sees && m.cooldown<=0 && Math.random() < m.agg * (dt/200);

      if (willChase){
        m.state="chase";
        m.cooldown = 900 + Settings.diff*260;
        AudioSys.beep(180, 120, "sawtooth", 0.06);
      }

      const speedMul = player.hidden ? 0.55 : 1.0;
      if (m.state==="chase" && !player.hidden){
        const dir = (player.x > m.x) ? 1 : -1;
        m.x += dir * Math.abs(m.vx) * 1.25 * speedMul * (dt/1000);
        // exit chase if too far
        if (dist > 520) m.state="patrol";
      } else {
        m.x += m.vx * speedMul * (dt/1000);
      }

      if (m.x < minX){ m.x=minX; m.vx=Math.abs(m.vx); m.state="patrol"; }
      if (m.x > maxX){ m.x=maxX; m.vx=-Math.abs(m.vx); m.state="patrol"; }

      m.y = Math.floor(R.floorY - 150 + Math.sin((now()/520) + game.floor)*14);

      const hit={x:m.x-m.w/2, y:m.y-m.h/2, w:m.w, h:m.h};
      if (rectsOverlap(hit,pbox) && !player.hidden) damage(m.name + " yakaladı.");

      game.lights = lerp(game.lights, 0.84, 0.03);
      game.shake  = lerp(game.shake, 0.10, 0.03);
      return;
    }
  }

  /* =========================
     Interactions
  ========================= */
  function near(x,y,r){
    const dx=player.x-x, dy=player.y-y;
    return (dx*dx + dy*dy) <= r*r;
  }

  function updateInventoryUI(){
    const parts=[];
    if (player.flashlight) parts.push("Fener");
    if (game.inv.fuse) parts.push("Sigorta");
    if (game.inv.noteCode) parts.push("Not");
    if (parts.length===0) parts.push("-");
    uiInv.textContent = parts.join(", ");
  }

  function markGoalDone(){
    if (!game.goal) return;
    if (game.goal.type===GoalType.COLLECT_ORBS){
      if (game.obj.orbsGot >= game.goal.need){
        game.goal.done=true;
      }
    } else {
      game.goal.done=true;
    }
  }

  function interact(){
    if (game.state!=="play") return;
    const R=game.room;
    // desk
    if (near(R.deskX+R.deskW/2, R.floorY-10, 130)){
      if (game.obj.drawerUsed){
        showToast("Çekmece boş.", 1200);
        return;
      }
      game.obj.drawerUsed=true;

      if (game.goal.type===GoalType.FIND_KEY && !game.goal.done){
        game.goal.done=true;
        AudioSys.beep(880, 120, "square", 0.07);
        showToast("Anahtar bulundu. Asansör açıldı.", 1900);
        return;
      }

      if (game.goal.type===GoalType.FIX_FUSE && !game.inv.fuse){
        const rnd=seededRand(hashStr("FuseInDesk:"+game.floor+":"+game.theme));
        if (rnd() < 0.62){
          game.inv.fuse=true;
          AudioSys.beep(660, 90, "square", 0.06);
          showToast("Sigorta bulundu. Panele git.", 1900);
          updateInventoryUI();
          return;
        }
      }

      if (game.goal.type===GoalType.KEYPAD_CODE && !game.inv.noteCode){
        const rnd=seededRand(hashStr("CodeInDesk:"+game.floor+":"+game.theme));
        if (rnd() < 0.55){
          game.inv.noteCode = game.obj.code;
          game.obj.noteTaken=true;
          AudioSys.beep(520, 90, "triangle", 0.06);
          showToast("Not: şifre " + game.inv.noteCode, 2200);
          updateInventoryUI();
          return;
        }
      }

      // generic loot: spare keys/battery
      const roll = Math.random();
      if (roll < 0.22){
        player.keys += 1;
        AudioSys.beep(740, 80, "square", 0.06);
        showToast("Yedek anahtar +1", 1400);
      } else if (roll < 0.42){
        player.battery = clamp(player.battery + 22, 0, 100);
        AudioSys.beep(600, 80, "triangle", 0.06);
        showToast("Pil +22", 1400);
      } else {
        showToast("İşe yarar bir şey yok.", 1400);
      }
      return;
    }

    // note
    if (!game.obj.noteTaken && near(R.noteX+18, R.noteY+10, 90)){
      game.obj.noteTaken=true;
      game.inv.noteCode = game.obj.code;
      AudioSys.beep(520, 90, "triangle", 0.06);
      showToast("Not: şifre " + game.inv.noteCode, 2200);
      updateInventoryUI();
      return;
    }

    // panel
    if (near(R.panelX+R.panelW/2, R.panelY+R.panelH/2, 150)){
      if (game.goal.type!==GoalType.FIX_FUSE){
        showToast("Panel bu katta gerekli değil.", 1300);
        return;
      }
      if (game.obj.panelFixed){
        showToast("Panel zaten onarıldı.", 1200);
        return;
      }
      if (!game.inv.fuse){
        showToast("Sigorta gerekli.", 1400);
        return;
      }
      game.obj.panelFixed=true;
      game.inv.fuse=false;
      markGoalDone();
      AudioSys.thump();
      showToast("Panel onarıldı. Asansör açıldı.", 1900);
      updateInventoryUI();
      return;
    }

    // keypad
    if (near(R.keypadX+R.keypadW/2, R.keypadY+R.keypadH/2, 150)){
      if (game.goal.type!==GoalType.KEYPAD_CODE){
        showToast("Şifre bu katta yok.", 1200);
        return;
      }
      if (game.goal.done){
        showToast("Şifre zaten çözüldü.", 1200);
        return;
      }
      if (!game.inv.noteCode){
        showToast("Not gerekli. İpucu ara.", 1500);
        return;
      }
      game.goal.done=true;
      AudioSys.beep(980, 140, "square", 0.08);
      showToast("Şifre doğru. Asansör açıldı.", 1900);
      return;
    }

    // lever
    if (near(R.leverX+R.leverW/2, R.leverY+R.leverH/2, 150)){
      if (game.goal.type!==GoalType.PULL_LEVER){
        showToast("Kol kilitli.", 1200);
        return;
      }
      if (game.obj.leverPulled){
        showToast("Kol zaten çekildi.", 1200);
        return;
      }
      game.obj.leverPulled=true;
      markGoalDone();
      AudioSys.thump();
      showToast("Kolu çektin. Asansör açıldı.", 1900);
      return;
    }

    // terminal scan
    if (near(R.termX+R.termW/2, R.termY+R.termH/2, 170)){
      if (game.goal.type!==GoalType.SCAN_TERMINAL){
        showToast("Terminal kilitli.", 1200);
        return;
      }
      if (game.obj.termDone){
        showToast("Terminal zaten tamam.", 1200);
        return;
      }
      // short “scan” minigame: stand still for 2s
      game.obj.termDone = true;
      game.goal.done = true;
      AudioSys.beep(420, 120, "sine", 0.06);
      AudioSys.beep(560, 120, "sine", 0.06);
      showToast("Tarama bitti. Asansör açıldı.", 1900);
      return;
    }

    // collect orbs
    if (game.goal.type===GoalType.COLLECT_ORBS){
      for(const o of game.obj.orbs){
        if (o.taken) continue;
        const dx=player.x-o.x, dy=(player.y-player.h*0.6)-o.y;
        if (dx*dx + dy*dy < (o.r*o.r*8)){
          o.taken=true;
          game.obj.orbsGot += 1;
          AudioSys.beep(620, 90, "triangle", 0.06);
          showToast(`İz toplandı: ${game.obj.orbsGot}/${game.goal.need}`, 1200);
          if (game.obj.orbsGot >= game.goal.need){
            game.goal.done=true;
            AudioSys.beep(980, 140, "square", 0.08);
            showToast("Görev tamam. Asansör açıldı.", 1600);
          }
          return;
        }
      }
      showToast("Yakında toplanacak iz yok.", 1200);
      return;
    }

    showToast("Etkileşim yok. Nesneye yaklaş.", 1200);
  }

  function toggleHide(){
    const R=game.room;
    if (!near(R.lockerX+R.lockerW/2, R.floorY-10, 150)){
      showToast("Dolaba yaklaş.", 1200);
      return;
    }
    player.hidden = !player.hidden;
    AudioSys.beep(player.hidden?260:320, 70, "square", 0.05);
    showToast(player.hidden ? "Dolaba girdin." : "Dolaptan çıktın.", 1100);
  }

  function toggleFlashlight(){
    player.flashlight = !player.flashlight;
    AudioSys.beep(player.flashlight?520:380, 70, "square", 0.05);
    showToast(player.flashlight ? "Fener açık." : "Fener kapalı.", 1000);
  }

  function tryElevator(){
    const R=game.room;
    if (!near(R.elevX+R.elevW/2, R.floorY-10, 200)){
      showToast("Asansöre yaklaş.", 1200);
      return;
    }
    if (!game.goal || !game.goal.done){
      showToast("Önce görevi bitir.", 1400);
      return;
    }
    // lock floors consume spare key
    if (game.floor % 10 === 0){
      if (player.keys <= 0){
        showToast("Bu asansör kilitli. Yedek anahtar gerek.", 1700);
        return;
      }
      player.keys -= 1;
    }
    enterMoving();
  }

  /* =========================
     Damage / End
  ========================= */
  function damage(reason){
    if (player.invuln>0) return;
    player.hp -= 1;
    player.invuln = 1200;
    game.shake = 1.0;
    game.lights = 0.62;
    AudioSys.thump();
    showToast("Hasar: " + reason, 2000);
    if (player.hp<=0){
      game.state="fail";
      showToast("Oyun bitti.\nEsc: Menü", 4000);
    }
  }

  /* =========================
     Enter floor / moving
  ========================= */
  function enterFloor(f){
    game.floor = clamp(f,1,100);
    game.theme = themeForFloor(game.floor);
    game.pal = paletteForFloor(game.floor, game.theme);
    game.room = roomForFloor(game.floor, game.theme);
    resetPerFloor();

    game.goal = goalForFloor(game.floor, game.theme);
    if (game.goal.type===GoalType.COLLECT_ORBS) spawnOrbs();

    game.monster = monsterForFloor(game.floor, game.theme, Settings.diff);
    initMonsterPos();

    const R=game.room;
    player.x = clamp(R.leftWall+160, R.leftWall+40, R.rightWall-40);
    player.y = R.floorY;
    player.vx = 0;
    player.hidden = false;

    game.state="play";
    game.t=0;
    game.lights=1;
    game.shake=0;

    // dark theme: encourage flashlight
    if (game.theme===Themes.DARK){
      showToast("Karanlık kat. Fener (F) işe yarar.", 2000);
    }

    if (game.monster && game.monster.type!==MonsterType.NONE){
      uiThreat.textContent="Var";
      showToast("Tehdit: " + game.monster.name + "\n" + (game.monster.help||""), 2600);
    } else {
      uiThreat.textContent="Yok";
      showToast("Bu kat sakin. Görevi bitir.", 1700);
    }

    updateHUD();
    saveGame();
  }

  function enterMoving(){
    game.state="moving";
    game.t=0;
    game.shake=0.6;
    game.lights=0.90;
    AudioSys.hiss(180);
    showToast("Asansör hareket ediyor...", 1400);
    saveGame();
  }

  function enterWin(){
    game.state="win";
    showToast("100. kata ulaştın. Kazandın.", 4200);
    saveGame();
  }

  /* =========================
     HUD update
  ========================= */
  function updateHUD(){
    uiFloor.textContent = String(game.floor);
    uiHP.textContent = String(player.hp);
    uiStam.textContent = String(Math.round(player.stamina));
    uiBat.textContent = String(Math.round(player.battery));
    uiGoal.textContent = game.goal
      ? (game.goal.type===GoalType.COLLECT_ORBS
          ? `${game.goal.text} (${game.obj.orbsGot}/${game.goal.need})${game.goal.done?" (bitti)":""}`
          : `${game.goal.text}${game.goal.done?" (bitti)":""}`)
      : "-";
    updateInventoryUI();
  }

  /* =========================
     Main update/render
  ========================= */
  let last = now();

  function update(dt){
    if (!game.running) return;

    if (toastTimer>0){
      toastTimer -= dt;
      if (toastTimer<=0) toast.classList.remove("show");
    }

    if (player.invuln>0) player.invuln -= dt;

    const menuOpen = !menu.classList.contains("hide");

    // Menu open -> freeze gameplay but still render
    if (menuOpen){
      player.vx = 0;
      updateHUD();
      return;
    }

    if (game.state==="fail" || game.state==="win"){
      player.vx=0;
      updateHUD();
      return;
    }

    const R=game.room;

    // sprint + stamina
    const wantSprint = isDown("shift");
    const canSprint = (player.stamina > 5);
    const sprinting = wantSprint && canSprint && !player.hidden && game.state==="play";
    const baseSpeed = 290;
    const sprintMul = sprinting ? 1.55 : 1.0;

    let ax=0;
    if (!player.hidden){
      if (isDown("a") || isDown("arrowleft")) ax -= 1;
      if (isDown("d") || isDown("arrowright")) ax += 1;
    }

    player.vx = ax * baseSpeed * sprintMul;

    if (player.vx !== 0) player.face = player.vx>0 ? 1 : -1;

    if (game.state==="play"){
      player.x += player.vx * (dt/1000);
      player.x = clamp(player.x, R.leftWall+30, R.rightWall-30);
      player.y = R.floorY;

      // stamina drain/regen
      if (sprinting){
        player.stamina = clamp(player.stamina - (0.09 + Settings.diff*0.02) * dt, 0, 100);
      } else {
        player.stamina = clamp(player.stamina + 0.06 * dt, 0, 100);
      }

      // battery drain if flashlight on
      const batDrain = (game.theme===Themes.DARK ? (0.012 + Settings.diff*0.004) : 0.006) * dt;
      if (player.flashlight && player.battery>0 && !player.hidden){
        player.battery = clamp(player.battery - batDrain, 0, 100);
        if (player.battery<=0){
          player.flashlight=false;
          showToast("Pil bitti.", 1500);
        }
      }

      // interactions
      if (wasPressed("w") || wasPressed("arrowup")) interact();
      if (wasPressed(" ") || wasPressed("spacebar")) toggleHide();
      if (wasPressed("f")) toggleFlashlight();
      if (wasPressed("enter")) tryElevator();

      // monster update
      if (game.monster && game.monster.type!==MonsterType.NONE){
        updateMonster(dt);
      } else {
        game.lights = lerp(game.lights, 1.0, 0.02);
        game.shake  = lerp(game.shake, 0, 0.03);
      }

      // subtle ambient
      if (Math.random() < 0.0008 * (dt/16)) AudioSys.beep(90, 60, "sine", 0.02);
    }

    if (game.state==="moving"){
      game.t += dt;
      player.vx=0;
      game.lights = lerp(game.lights, 0.86, 0.03);
      game.shake  = lerp(game.shake, 0.35, 0.04);

      if (game.t > 1200){
        const next = game.floor + 1;
        if (next >= 100){
          enterFloor(100);
          enterWin();
        } else {
          enterFloor(next);
        }
      }
    }

    updateHUD();
  }

  function render(){
    if (!game.running) return;

    const W=cv.width,H=cv.height;
    const shakeScale = Settings.shake;
    const sx = (Math.random()*2-1) * (game.shake*10*shakeScale);
    const sy = (Math.random()*2-1) * (game.shake*6*shakeScale);

    ctx.save();
    ctx.translate(sx, sy);

    drawRoom();

    // warning stripes in warn phases
    if (game.monster){
      if (game.monster.type===MonsterType.PASSER && game.monster.phase==="warn") drawWarningStripes(0.26);
      if (game.monster.type===MonsterType.WAVES && game.monster.phase==="warn") drawWarningStripes(0.28);
    }

    // monster
    if (game.monster && game.monster.type!==MonsterType.NONE){
      const m=game.monster;
      if ((m.type===MonsterType.ROAMER || m.type===MonsterType.PASSER || m.type===MonsterType.WAVES) && !m.y){
        m.y = Math.floor(game.room.floorY - 140);
      }
      drawMonster(m);
    }

    drawPlayer();

    // base lighting overlay
    ctx.save();
    const dark = clamp(1 - game.lights, 0, 0.90);
    ctx.fillStyle = `rgba(0,0,0,${dark})`;
    ctx.fillRect(0,0,W,H);
    ctx.restore();

    // darkness + flashlight
    applyFlashlight();

    vignette(0.30 + (1-game.lights)*0.45);

    // state overlays
    if (game.state==="fail") drawBanner("OYUN BİTTİ", "Esc: Menü");
    if (game.state==="win") drawBanner("KAZANDIN", "100. kat");

    ctx.restore();
  }

  function drawBanner(title, sub){
    const W=cv.width,H=cv.height;
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.globalAlpha=0.9;
    ctx.fillStyle="rgba(0,0,0,.62)";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha=1;

    const bw=Math.min(780, Math.floor(W*0.82));
    const bh=Math.min(260, Math.floor(H*0.34));
    const x=(W-bw)/2, y=(H-bh)/2;

    ctx.fillStyle="rgba(10,14,26,.90)";
    pxRect(x,y,bw,bh);
    ctx.strokeStyle="rgba(255,255,255,.16)";
    ctx.strokeRect(x,y,bw,bh);

    ctx.fillStyle="rgba(255,255,255,.92)";
    ctx.font=`${Math.max(28, Math.floor(Math.min(W,H)/24))}px ui-monospace, Menlo, Consolas, monospace`;
    const tw=ctx.measureText(title).width;
    ctx.fillText(title, (W-tw)/2, y+Math.floor(bh*0.48));

    ctx.fillStyle=game.pal ? game.pal.neon : "rgba(106,215,255,.9)";
    ctx.font=`${Math.max(14, Math.floor(Math.min(W,H)/56))}px system-ui, Arial`;
    const sw=ctx.measureText(sub).width;
    ctx.fillText(sub, (W-sw)/2, y+Math.floor(bh*0.68));
    ctx.restore();
  }

  function frame(){
    const t=now();
    const dt=Math.min(33, t-last);
    last=t;

    update(dt);
    render();

    pressed.clear();
    requestAnimationFrame(frame);
  }

  /* =========================
     Menu / Buttons
  ========================= */
  function openMenu(){
    menu.classList.remove("hide");
    showToast("Menü", 800);
  }
  function closeMenu(){
    menu.classList.add("hide");
    showToast("Devam", 800);
  }

  btnHow.addEventListener("click", ()=>{
    howPanel.classList.toggle("hide");
    settingsPanel.classList.add("hide");
  });
  btnSettings.addEventListener("click", ()=>{
    settingsPanel.classList.toggle("hide");
    howPanel.classList.add("hide");
  });

  btnWipe.addEventListener("click", ()=>{
    wipeSave();
    showToast("Kayıt silindi.", 1400);
  });

  btnNew.addEventListener("click", ()=>{
    player.hp=3;
    player.keys=0;
    player.stamina=100;
    player.battery=100;
    player.flashlight=false;
    enterFloor(1);
    closeMenu();
    showToast("Yeni oyun başladı.", 1200);
  });

  btnContinue.addEventListener("click", ()=>{
    const s=loadSave();
    if (!s){
      showToast("Kayıt yok. Yeni oyun başlat.", 1600);
      return;
    }
    player.hp = clamp(s.hp ?? 3, 1, 3);
    player.keys = Math.max(0, s.keys ?? 0);
    player.stamina = 100;
    player.battery = clamp(s.bat ?? 100, 0, 100);
    player.flashlight = false;
    enterFloor(clamp(s.floor ?? 1, 1, 100));
    closeMenu();
    showToast("Kayıt yüklendi.", 1200);
  });

  rngVol.addEventListener("input", ()=>{
    Settings.vol = clamp(parseInt(rngVol.value,10)/100, 0,1);
    AudioSys.setVol(Settings.vol);
    saveSettings();
  });
  rngDiff.addEventListener("input", ()=>{
    Settings.diff = clamp(parseInt(rngDiff.value,10),1,5);
    saveSettings();
  });
  rngShake.addEventListener("input", ()=>{
    Settings.shake = clamp(parseInt(rngShake.value,10)/100, 0,1);
    saveSettings();
  });

  window.addEventListener("keydown",(e)=>{
    const k=(e.key||"").toLowerCase();
    if (k==="escape" && game.running){
      const open = !menu.classList.contains("hide");
      if (open) closeMenu(); else openMenu();
    }
  });

  /* =========================
     Boot
  ========================= */
  function updateSettingsUI(){
    rngVol.value = String(Math.round(Settings.vol*100));
    rngDiff.value = String(Settings.diff);
    rngShake.value = String(Math.round(Settings.shake*100));
    AudioSys.setVol(Settings.vol);
  }

  function updateMenuContinueState(){
    const s=loadSave();
    btnContinue.disabled = !s;
  }

  function start(){
    loadSettings();
    updateSettingsUI();

    hud.classList.remove("hide");
    game.running=true;

    const s=loadSave();
    if (s){
      showToast("Kayıt bulundu. Devam edebilirsin.", 1800);
    } else {
      showToast("Yeni oyun ile başla.", 1600);
    }
    updateMenuContinueState();

    // start loop
    requestAnimationFrame(frame);
  }

  start();

})();
</script>
</body>
</html>

